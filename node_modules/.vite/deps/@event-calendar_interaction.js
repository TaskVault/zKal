import {
  addDay,
  addDuration,
  ancestor,
  assign,
  bgEvent,
  cloneDate,
  cloneEvent,
  createDuration,
  getElementWithPayload,
  getPayload,
  helperEvent,
  listView,
  max,
  min,
  rect,
  subtractDuration,
  timelineView,
  toEventWithLocalDates,
  toISOString,
  toLocalDate,
  toViewWithLocalDates
} from "./chunk-7NNYD6EP.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-TE5TN4QG.js";
import {
  writable
} from "./chunk-ZDKSVB7X.js";
import {
  SvelteComponentDev,
  add_location,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  create_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen,
  listen_dev,
  mount_component,
  noop,
  run_all,
  safe_not_equal,
  set_store_value,
  space,
  transition_in,
  transition_out,
  validate_slots,
  validate_store
} from "./chunk-CBQLSORC.js";
import "./chunk-GZA2YTNP.js";
import "./chunk-LNEMQRCO.js";

// node_modules/@event-calendar/interaction/src/utils.js
var busy = false;
function animate(fn) {
  if (!busy) {
    busy = true;
    window.requestAnimationFrame(() => {
      fn();
      busy = false;
    });
  }
}
function limit(value, minLimit, maxLimit) {
  return max(minLimit, min(maxLimit, value));
}

// node_modules/@event-calendar/interaction/src/Action.svelte
var { window: window_1 } = globals;
function create_fragment(ctx) {
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: noop,
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "pointermove",
            /*handlePointerMove*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "pointerup",
            /*handlePointerUp*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "pointercancel",
            /*handlePointerUp*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "scroll",
            /*handleScroll*/
            ctx[0],
            false,
            false,
            false,
            false
          ),
          listen_dev(window_1, "selectstart", createPreventDefaultHandler(
            /*complexAction*/
            ctx[35]
          ), false, false, false, false),
          listen_dev(
            window_1,
            "contextmenu",
            function() {
              if (is_function(createPreventDefaultHandler(
                /*contextmenu_handler*/
                ctx[43]
              )))
                createPreventDefaultHandler(
                  /*contextmenu_handler*/
                  ctx[43]
                ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "touchstart",
            /*handleTouchStart*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "touchmove",
            /*touchmove_handler*/
            ctx[42],
            { passive: false },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var ACTION_DRAG = 1;
var ACTION_RESIZE = 2;
var ACTION_SELECT = 3;
var ACTION_CLICK = 4;
var ACTION_NO_ACTION = 5;
function validJsEvent(jsEvent) {
  return jsEvent.isPrimary && (jsEvent.pointerType !== "mouse" || jsEvent.buttons & 1);
}
function createPreventDefaultHandler(condition) {
  return (jsEvent) => {
    if (condition()) {
      jsEvent.preventDefault();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $_view;
  let $unselectFn;
  let $_events;
  let $_iEvents;
  let $selectBackgroundColor;
  let $_dayGrid;
  let $view;
  let $_iClass;
  let $dateClick;
  let $eventDrop;
  let $eventResize;
  let $eventDragStop;
  let $eventResizeStop;
  let $selectFn;
  let $unselectCancel;
  let $unselectAuto;
  let $slotWidth;
  let $slotHeight;
  let $dragScroll;
  let $eventDragStart;
  let $eventResizeStart;
  let $eventDragMinDistance;
  let $selectMinDistance;
  let $longPressDelay;
  let $eventLongPressDelay;
  let $selectLongPressDelay;
  let $datesAboveResources;
  let $_bodyEl;
  let $slotDuration;
  let $selectable;
  let $_draggable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Action", slots, []);
  let { _iEvents, _iClass, _events, _view, _dayGrid, _draggable, _bodyEl, dateClick, dragScroll, datesAboveResources, eventDragMinDistance, eventDragStart, eventDragStop, eventDrop, eventLongPressDelay, eventResizeStart, eventResizeStop, eventResize, longPressDelay, selectable, select: selectFn, selectBackgroundColor, selectLongPressDelay, selectMinDistance, slotDuration, slotHeight, slotWidth, unselect: unselectFn, unselectAuto, unselectCancel, view } = getContext("state");
  validate_store(_iEvents, "_iEvents");
  component_subscribe($$self, _iEvents, (value) => $$invalidate(72, $_iEvents = value));
  validate_store(_iClass, "_iClass");
  component_subscribe($$self, _iClass, (value) => $$invalidate(76, $_iClass = value));
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(71, $_events = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(69, $_view = value));
  validate_store(_dayGrid, "_dayGrid");
  component_subscribe($$self, _dayGrid, (value) => $$invalidate(74, $_dayGrid = value));
  validate_store(_draggable, "_draggable");
  component_subscribe($$self, _draggable, (value) => $$invalidate(99, $_draggable = value));
  validate_store(_bodyEl, "_bodyEl");
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(96, $_bodyEl = value));
  validate_store(dateClick, "dateClick");
  component_subscribe($$self, dateClick, (value) => $$invalidate(77, $dateClick = value));
  validate_store(dragScroll, "dragScroll");
  component_subscribe($$self, dragScroll, (value) => $$invalidate(87, $dragScroll = value));
  validate_store(datesAboveResources, "datesAboveResources");
  component_subscribe($$self, datesAboveResources, (value) => $$invalidate(95, $datesAboveResources = value));
  validate_store(eventDragMinDistance, "eventDragMinDistance");
  component_subscribe($$self, eventDragMinDistance, (value) => $$invalidate(90, $eventDragMinDistance = value));
  validate_store(eventDragStart, "eventDragStart");
  component_subscribe($$self, eventDragStart, (value) => $$invalidate(88, $eventDragStart = value));
  validate_store(eventDragStop, "eventDragStop");
  component_subscribe($$self, eventDragStop, (value) => $$invalidate(80, $eventDragStop = value));
  validate_store(eventDrop, "eventDrop");
  component_subscribe($$self, eventDrop, (value) => $$invalidate(78, $eventDrop = value));
  validate_store(eventLongPressDelay, "eventLongPressDelay");
  component_subscribe($$self, eventLongPressDelay, (value) => $$invalidate(93, $eventLongPressDelay = value));
  validate_store(eventResizeStart, "eventResizeStart");
  component_subscribe($$self, eventResizeStart, (value) => $$invalidate(89, $eventResizeStart = value));
  validate_store(eventResizeStop, "eventResizeStop");
  component_subscribe($$self, eventResizeStop, (value) => $$invalidate(81, $eventResizeStop = value));
  validate_store(eventResize, "eventResize");
  component_subscribe($$self, eventResize, (value) => $$invalidate(79, $eventResize = value));
  validate_store(longPressDelay, "longPressDelay");
  component_subscribe($$self, longPressDelay, (value) => $$invalidate(92, $longPressDelay = value));
  validate_store(selectable, "selectable");
  component_subscribe($$self, selectable, (value) => $$invalidate(98, $selectable = value));
  validate_store(selectFn, "selectFn");
  component_subscribe($$self, selectFn, (value) => $$invalidate(82, $selectFn = value));
  validate_store(selectBackgroundColor, "selectBackgroundColor");
  component_subscribe($$self, selectBackgroundColor, (value) => $$invalidate(73, $selectBackgroundColor = value));
  validate_store(selectLongPressDelay, "selectLongPressDelay");
  component_subscribe($$self, selectLongPressDelay, (value) => $$invalidate(94, $selectLongPressDelay = value));
  validate_store(selectMinDistance, "selectMinDistance");
  component_subscribe($$self, selectMinDistance, (value) => $$invalidate(91, $selectMinDistance = value));
  validate_store(slotDuration, "slotDuration");
  component_subscribe($$self, slotDuration, (value) => $$invalidate(97, $slotDuration = value));
  validate_store(slotHeight, "slotHeight");
  component_subscribe($$self, slotHeight, (value) => $$invalidate(86, $slotHeight = value));
  validate_store(slotWidth, "slotWidth");
  component_subscribe($$self, slotWidth, (value) => $$invalidate(85, $slotWidth = value));
  validate_store(unselectFn, "unselectFn");
  component_subscribe($$self, unselectFn, (value) => $$invalidate(70, $unselectFn = value));
  validate_store(unselectAuto, "unselectAuto");
  component_subscribe($$self, unselectAuto, (value) => $$invalidate(84, $unselectAuto = value));
  validate_store(unselectCancel, "unselectCancel");
  component_subscribe($$self, unselectCancel, (value) => $$invalidate(83, $unselectCancel = value));
  validate_store(view, "view");
  component_subscribe($$self, view, (value) => $$invalidate(75, $view = value));
  let action;
  let interacting;
  let event;
  let display;
  let date, newDate;
  let resource, newResource;
  let fromX, fromY;
  let toX, toY;
  let bodyEl, bodyRect, clipEl, clipRect;
  let delta;
  let allDay;
  let iClass;
  let minEnd;
  let selectStep;
  let selected;
  let noDateClick;
  let timer;
  let viewport;
  let margin;
  function drag(eventToDrag, jsEvent, resize, forceDate, forceMargin) {
    if (!action) {
      action = validJsEvent(jsEvent) ? resize ? ACTION_RESIZE : $_draggable(eventToDrag) ? ACTION_DRAG : ACTION_NO_ACTION : ACTION_NO_ACTION;
      if (complexAction()) {
        event = eventToDrag;
        common(jsEvent);
        if (forceDate) {
          date = forceDate;
        }
        if (forceMargin) {
          margin = forceMargin;
        }
        iClass = resize ? resize == "x" ? "resizingX" : "resizingY" : "dragging";
        if (resize) {
          minEnd = cloneDate(event.start);
          if (allDay) {
            minEnd.setUTCHours(event.end.getUTCHours(), event.end.getUTCMinutes(), event.end.getUTCSeconds(), 0);
            if (minEnd < event.start) {
              addDay(minEnd);
            }
          } else {
            addDuration(minEnd, $slotDuration);
          }
        }
        move(jsEvent);
      }
    }
  }
  function select(jsEvent) {
    if (!action) {
      action = validJsEvent(jsEvent) ? $selectable && !listView($view) ? ACTION_SELECT : ACTION_CLICK : ACTION_NO_ACTION;
      if (complexAction()) {
        common(jsEvent);
        iClass = "selecting";
        selectStep = allDay ? createDuration({ day: 1 }) : $slotDuration;
        event = {
          allDay,
          start: date,
          end: addDuration(cloneDate(date), selectStep),
          resourceIds: resource ? [resource.id] : []
        };
        move(jsEvent);
      }
    }
  }
  function noAction() {
    if (!action) {
      action = ACTION_NO_ACTION;
    }
  }
  function common(jsEvent) {
    window.getSelection().removeAllRanges();
    fromX = toX = jsEvent.clientX;
    fromY = toY = jsEvent.clientY;
    let dayEl = getElementWithPayload(toX, toY);
    ({ allDay, date, resource } = getPayload(dayEl)(toX, toY));
    if (timelineView($view)) {
      bodyEl = clipEl = $_bodyEl;
    } else {
      bodyEl = ancestor(dayEl, resource ? 4 : 3);
      clipEl = ancestor(dayEl, resource && (dragging() || $datesAboveResources) ? 2 : 1);
    }
    calcViewport();
    if (jsEvent.pointerType !== "mouse") {
      $$invalidate(1, timer = setTimeout(
        () => {
          if (action) {
            interacting = true;
            move(jsEvent);
          }
        },
        (selecting() ? $selectLongPressDelay : $eventLongPressDelay) ?? $longPressDelay
      ));
    }
  }
  function move(jsEvent) {
    if (interacting || jsEvent && jsEvent.pointerType === "mouse" && distance() >= (selecting() ? $selectMinDistance : $eventDragMinDistance)) {
      interacting = true;
      unselect(jsEvent);
      set_store_value(_iClass, $_iClass = iClass, $_iClass);
      if (!$_iEvents[0]) {
        if (selecting()) {
          createIEventSelect();
        } else {
          createIEvent(jsEvent, resizing() ? $eventResizeStart : $eventDragStart);
        }
      }
      let dayEl = findDayEl();
      if (dayEl) {
        let newAllDay;
        ({ allDay: newAllDay, date: newDate, resource: newResource } = getPayload(dayEl)(toX, toY));
        if (newAllDay === allDay) {
          delta = createDuration((newDate - date) / 1e3);
          set_store_value(_iEvents, $_iEvents[0].end = addDuration(cloneDate(event.end), delta), $_iEvents);
          if (resizing()) {
            if ($_iEvents[0].end < minEnd) {
              set_store_value(_iEvents, $_iEvents[0].end = minEnd, $_iEvents);
            }
          } else if (selecting()) {
            if ($_iEvents[0].end < event.end) {
              set_store_value(_iEvents, $_iEvents[0].start = subtractDuration($_iEvents[0].end, selectStep), $_iEvents);
              set_store_value(_iEvents, $_iEvents[0].end = event.end, $_iEvents);
            } else {
              set_store_value(_iEvents, $_iEvents[0].start = event.start, $_iEvents);
            }
          } else {
            set_store_value(_iEvents, $_iEvents[0].start = addDuration(cloneDate(event.start), delta), $_iEvents);
            if (resource) {
              set_store_value(_iEvents, $_iEvents[0].resourceIds = event.resourceIds.filter((id) => id !== resource.id), $_iEvents);
              $_iEvents[0].resourceIds.push(newResource.id);
            }
          }
        }
      }
    }
    if ($dragScroll) {
      let thresholdY = $slotHeight * 2;
      let thresholdX = $slotWidth;
      animate(() => {
        if (bodyEl) {
          if (toY < thresholdY) {
            window.scrollBy(0, max(-10, (toY - thresholdY) / 3));
          }
          if (toY < bodyRect.top + thresholdY) {
            bodyEl.scrollTop += max(-10, (toY - bodyRect.top - thresholdY) / 3);
          }
          if (toY > window.innerHeight - thresholdY) {
            window.scrollBy(0, min(10, (toY - window.innerHeight + thresholdY) / 3));
          }
          if (toY > bodyRect.bottom - thresholdY) {
            bodyEl.scrollTop += min(10, (toY - bodyRect.bottom + thresholdY) / 3);
          }
          if (timelineView($view)) {
            if (toX < bodyRect.left + thresholdX) {
              bodyEl.scrollLeft += max(-10, (toX - bodyRect.left - thresholdX) / 3);
            }
            if (toX > bodyRect.right - thresholdX) {
              bodyEl.scrollLeft += min(10, (toX - bodyRect.right + thresholdX) / 3);
            }
          }
        }
      });
    }
  }
  function handleScroll() {
    if (complexAction()) {
      calcViewport();
      move();
    }
  }
  function handlePointerMove(jsEvent) {
    if (complexAction() && jsEvent.isPrimary) {
      toX = jsEvent.clientX;
      toY = jsEvent.clientY;
      move(jsEvent);
    }
  }
  function handlePointerUp(jsEvent) {
    if (selected && $unselectAuto && !($unselectCancel && jsEvent.target.closest($unselectCancel))) {
      unselect(jsEvent);
    }
    if (action && jsEvent.isPrimary) {
      if (interacting) {
        if (selecting()) {
          selected = true;
          if (is_function($selectFn)) {
            let { start, end } = toEventWithLocalDates($_iEvents[0]);
            $selectFn({
              start,
              end,
              startStr: toISOString($_iEvents[0].start),
              endStr: toISOString($_iEvents[0].end),
              allDay,
              jsEvent,
              view: toViewWithLocalDates($_view),
              resource
            });
          }
        } else {
          event.display = display;
          let callback = resizing() ? $eventResizeStop : $eventDragStop;
          if (is_function(callback)) {
            callback({
              event: toEventWithLocalDates(event),
              jsEvent,
              view: toViewWithLocalDates($_view)
            });
          }
          let oldEvent = cloneEvent(event);
          updateEvent(event, $_iEvents[0]);
          destroyIEvent();
          callback = resizing() ? $eventResize : $eventDrop;
          if (is_function(callback)) {
            let eventRef = event;
            let info;
            if (resizing()) {
              info = { endDelta: delta };
            } else {
              info = {
                delta,
                oldResource: resource !== newResource ? resource : void 0,
                newResource: resource !== newResource ? newResource : void 0
              };
            }
            callback(assign(info, {
              event: toEventWithLocalDates(event),
              oldEvent: toEventWithLocalDates(oldEvent),
              jsEvent,
              view: toViewWithLocalDates($_view),
              revert() {
                updateEvent(eventRef, oldEvent);
              }
            }));
          }
        }
      } else {
        if (clicking() || selecting()) {
          if (is_function($dateClick) && !noDateClick) {
            toX = jsEvent.clientX;
            toY = jsEvent.clientY;
            let dayEl = getElementWithPayload(toX, toY);
            if (dayEl) {
              let { allDay: allDay2, date: date2, resource: resource2 } = getPayload(dayEl)(toX, toY);
              $dateClick({
                allDay: allDay2,
                date: toLocalDate(date2),
                dateStr: toISOString(date2),
                dayEl,
                jsEvent,
                view: toViewWithLocalDates($_view),
                resource: resource2
              });
            }
          }
        }
      }
      interacting = false;
      action = fromX = fromY = toX = toY = event = display = date = newDate = resource = newResource = delta = allDay = set_store_value(_iClass, $_iClass = minEnd = selectStep = margin = void 0, $_iClass);
      bodyEl = clipEl = bodyRect = clipRect = void 0;
      if (timer) {
        clearTimeout(timer);
        $$invalidate(1, timer = void 0);
      }
    }
    noDateClick = false;
  }
  function findDayEl() {
    return getElementWithPayload(limit(toX, viewport[0], viewport[1]), limit(toY, viewport[2], viewport[3]));
  }
  function calcViewport() {
    bodyRect = rect(bodyEl);
    clipRect = rect(clipEl);
    viewport = [
      max(0, clipRect.left + (timelineView($view) ? 1 : $_dayGrid ? 0 : 8)),
      min(
        document.documentElement.clientWidth,
        clipRect.left + clipEl.clientWidth
      ) - 2,
      max(
        0,
        bodyRect.top
        // top
      ),
      min(document.documentElement.clientHeight, bodyRect.top + bodyEl.clientHeight) - 2
    ];
  }
  function createIEvent(jsEvent, callback) {
    if (is_function(callback)) {
      callback({
        event: toEventWithLocalDates(event),
        jsEvent,
        view: toViewWithLocalDates($_view)
      });
    }
    display = event.display;
    event.display = "preview";
    set_store_value(_iEvents, $_iEvents[0] = cloneEvent(event), $_iEvents);
    if (margin !== void 0) {
      set_store_value(_iEvents, $_iEvents[0]._margin = margin, $_iEvents);
    }
    event.display = "ghost";
    _events.set($_events);
  }
  function createIEventSelect() {
    set_store_value(
      _iEvents,
      $_iEvents[0] = {
        id: "{select}",
        allDay: event.allDay,
        start: event.start,
        title: "",
        display: "preview",
        extendedProps: {},
        backgroundColor: $selectBackgroundColor,
        resourceIds: event.resourceIds
      },
      $_iEvents
    );
  }
  function destroyIEvent() {
    set_store_value(_iEvents, $_iEvents[0] = null, $_iEvents);
  }
  function updateEvent(target, source) {
    target.start = source.start;
    target.end = source.end;
    target.resourceIds = source.resourceIds;
    _events.set($_events);
  }
  function distance() {
    return Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
  }
  function dragging() {
    return action === ACTION_DRAG;
  }
  function resizing() {
    return action === ACTION_RESIZE;
  }
  function clicking() {
    return action === ACTION_CLICK;
  }
  function selecting() {
    return action === ACTION_SELECT;
  }
  function complexAction() {
    return action && action < ACTION_CLICK;
  }
  function unselect(jsEvent) {
    if (selected) {
      selected = false;
      destroyIEvent();
      if (is_function($unselectFn)) {
        $unselectFn({
          jsEvent,
          view: toViewWithLocalDates($_view)
        });
      }
    }
  }
  function noClick() {
    noDateClick = true;
  }
  _view.subscribe(unselect);
  function handleTouchStart(jsEvent) {
    if (complexAction()) {
      let target = jsEvent.target;
      let stops = [];
      let stop = () => run_all(stops);
      stops.push(listen(target, "touchmove", createPreventDefaultHandler(() => interacting)));
      stops.push(listen(target, "touchend", stop));
      stops.push(listen(target, "touchcancel", stop));
    }
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Action> was created with unknown prop '${key}'`);
  });
  function touchmove_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const contextmenu_handler = () => timer;
  $$self.$capture_state = () => ({
    getContext,
    is_function,
    listen,
    run_all,
    addDay,
    addDuration,
    ancestor,
    assign,
    cloneDate,
    cloneEvent,
    createDuration,
    getElementWithPayload,
    getPayload,
    min,
    max,
    rect,
    subtractDuration,
    toEventWithLocalDates,
    toISOString,
    toLocalDate,
    toViewWithLocalDates,
    listView,
    timelineView,
    animate,
    limit,
    _iEvents,
    _iClass,
    _events,
    _view,
    _dayGrid,
    _draggable,
    _bodyEl,
    dateClick,
    dragScroll,
    datesAboveResources,
    eventDragMinDistance,
    eventDragStart,
    eventDragStop,
    eventDrop,
    eventLongPressDelay,
    eventResizeStart,
    eventResizeStop,
    eventResize,
    longPressDelay,
    selectable,
    selectFn,
    selectBackgroundColor,
    selectLongPressDelay,
    selectMinDistance,
    slotDuration,
    slotHeight,
    slotWidth,
    unselectFn,
    unselectAuto,
    unselectCancel,
    view,
    ACTION_DRAG,
    ACTION_RESIZE,
    ACTION_SELECT,
    ACTION_CLICK,
    ACTION_NO_ACTION,
    action,
    interacting,
    event,
    display,
    date,
    newDate,
    resource,
    newResource,
    fromX,
    fromY,
    toX,
    toY,
    bodyEl,
    bodyRect,
    clipEl,
    clipRect,
    delta,
    allDay,
    iClass,
    minEnd,
    selectStep,
    selected,
    noDateClick,
    timer,
    viewport,
    margin,
    drag,
    select,
    noAction,
    common,
    move,
    handleScroll,
    handlePointerMove,
    handlePointerUp,
    findDayEl,
    calcViewport,
    createIEvent,
    createIEventSelect,
    destroyIEvent,
    updateEvent,
    distance,
    dragging,
    resizing,
    clicking,
    selecting,
    complexAction,
    validJsEvent,
    unselect,
    noClick,
    handleTouchStart,
    createPreventDefaultHandler,
    $_view,
    $unselectFn,
    $_events,
    $_iEvents,
    $selectBackgroundColor,
    $_dayGrid,
    $view,
    $_iClass,
    $dateClick,
    $eventDrop,
    $eventResize,
    $eventDragStop,
    $eventResizeStop,
    $selectFn,
    $unselectCancel,
    $unselectAuto,
    $slotWidth,
    $slotHeight,
    $dragScroll,
    $eventDragStart,
    $eventResizeStart,
    $eventDragMinDistance,
    $selectMinDistance,
    $longPressDelay,
    $eventLongPressDelay,
    $selectLongPressDelay,
    $datesAboveResources,
    $_bodyEl,
    $slotDuration,
    $selectable,
    $_draggable
  });
  $$self.$inject_state = ($$props2) => {
    if ("_iEvents" in $$props2)
      $$invalidate(2, _iEvents = $$props2._iEvents);
    if ("_iClass" in $$props2)
      $$invalidate(3, _iClass = $$props2._iClass);
    if ("_events" in $$props2)
      $$invalidate(4, _events = $$props2._events);
    if ("_view" in $$props2)
      $$invalidate(5, _view = $$props2._view);
    if ("_dayGrid" in $$props2)
      $$invalidate(6, _dayGrid = $$props2._dayGrid);
    if ("_draggable" in $$props2)
      $$invalidate(7, _draggable = $$props2._draggable);
    if ("_bodyEl" in $$props2)
      $$invalidate(8, _bodyEl = $$props2._bodyEl);
    if ("dateClick" in $$props2)
      $$invalidate(9, dateClick = $$props2.dateClick);
    if ("dragScroll" in $$props2)
      $$invalidate(10, dragScroll = $$props2.dragScroll);
    if ("datesAboveResources" in $$props2)
      $$invalidate(11, datesAboveResources = $$props2.datesAboveResources);
    if ("eventDragMinDistance" in $$props2)
      $$invalidate(12, eventDragMinDistance = $$props2.eventDragMinDistance);
    if ("eventDragStart" in $$props2)
      $$invalidate(13, eventDragStart = $$props2.eventDragStart);
    if ("eventDragStop" in $$props2)
      $$invalidate(14, eventDragStop = $$props2.eventDragStop);
    if ("eventDrop" in $$props2)
      $$invalidate(15, eventDrop = $$props2.eventDrop);
    if ("eventLongPressDelay" in $$props2)
      $$invalidate(16, eventLongPressDelay = $$props2.eventLongPressDelay);
    if ("eventResizeStart" in $$props2)
      $$invalidate(17, eventResizeStart = $$props2.eventResizeStart);
    if ("eventResizeStop" in $$props2)
      $$invalidate(18, eventResizeStop = $$props2.eventResizeStop);
    if ("eventResize" in $$props2)
      $$invalidate(19, eventResize = $$props2.eventResize);
    if ("longPressDelay" in $$props2)
      $$invalidate(20, longPressDelay = $$props2.longPressDelay);
    if ("selectable" in $$props2)
      $$invalidate(21, selectable = $$props2.selectable);
    if ("selectFn" in $$props2)
      $$invalidate(22, selectFn = $$props2.selectFn);
    if ("selectBackgroundColor" in $$props2)
      $$invalidate(23, selectBackgroundColor = $$props2.selectBackgroundColor);
    if ("selectLongPressDelay" in $$props2)
      $$invalidate(24, selectLongPressDelay = $$props2.selectLongPressDelay);
    if ("selectMinDistance" in $$props2)
      $$invalidate(25, selectMinDistance = $$props2.selectMinDistance);
    if ("slotDuration" in $$props2)
      $$invalidate(26, slotDuration = $$props2.slotDuration);
    if ("slotHeight" in $$props2)
      $$invalidate(27, slotHeight = $$props2.slotHeight);
    if ("slotWidth" in $$props2)
      $$invalidate(28, slotWidth = $$props2.slotWidth);
    if ("unselectFn" in $$props2)
      $$invalidate(29, unselectFn = $$props2.unselectFn);
    if ("unselectAuto" in $$props2)
      $$invalidate(30, unselectAuto = $$props2.unselectAuto);
    if ("unselectCancel" in $$props2)
      $$invalidate(31, unselectCancel = $$props2.unselectCancel);
    if ("view" in $$props2)
      $$invalidate(32, view = $$props2.view);
    if ("action" in $$props2)
      action = $$props2.action;
    if ("interacting" in $$props2)
      interacting = $$props2.interacting;
    if ("event" in $$props2)
      event = $$props2.event;
    if ("display" in $$props2)
      display = $$props2.display;
    if ("date" in $$props2)
      date = $$props2.date;
    if ("newDate" in $$props2)
      newDate = $$props2.newDate;
    if ("resource" in $$props2)
      resource = $$props2.resource;
    if ("newResource" in $$props2)
      newResource = $$props2.newResource;
    if ("fromX" in $$props2)
      fromX = $$props2.fromX;
    if ("fromY" in $$props2)
      fromY = $$props2.fromY;
    if ("toX" in $$props2)
      toX = $$props2.toX;
    if ("toY" in $$props2)
      toY = $$props2.toY;
    if ("bodyEl" in $$props2)
      bodyEl = $$props2.bodyEl;
    if ("bodyRect" in $$props2)
      bodyRect = $$props2.bodyRect;
    if ("clipEl" in $$props2)
      clipEl = $$props2.clipEl;
    if ("clipRect" in $$props2)
      clipRect = $$props2.clipRect;
    if ("delta" in $$props2)
      delta = $$props2.delta;
    if ("allDay" in $$props2)
      allDay = $$props2.allDay;
    if ("iClass" in $$props2)
      iClass = $$props2.iClass;
    if ("minEnd" in $$props2)
      minEnd = $$props2.minEnd;
    if ("selectStep" in $$props2)
      selectStep = $$props2.selectStep;
    if ("selected" in $$props2)
      selected = $$props2.selected;
    if ("noDateClick" in $$props2)
      noDateClick = $$props2.noDateClick;
    if ("timer" in $$props2)
      $$invalidate(1, timer = $$props2.timer);
    if ("viewport" in $$props2)
      viewport = $$props2.viewport;
    if ("margin" in $$props2)
      margin = $$props2.margin;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    handleScroll,
    timer,
    _iEvents,
    _iClass,
    _events,
    _view,
    _dayGrid,
    _draggable,
    _bodyEl,
    dateClick,
    dragScroll,
    datesAboveResources,
    eventDragMinDistance,
    eventDragStart,
    eventDragStop,
    eventDrop,
    eventLongPressDelay,
    eventResizeStart,
    eventResizeStop,
    eventResize,
    longPressDelay,
    selectable,
    selectFn,
    selectBackgroundColor,
    selectLongPressDelay,
    selectMinDistance,
    slotDuration,
    slotHeight,
    slotWidth,
    unselectFn,
    unselectAuto,
    unselectCancel,
    view,
    handlePointerMove,
    handlePointerUp,
    complexAction,
    handleTouchStart,
    drag,
    select,
    noAction,
    unselect,
    noClick,
    touchmove_handler,
    contextmenu_handler
  ];
}
var Action = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        drag: 37,
        select: 38,
        noAction: 39,
        handleScroll: 0,
        unselect: 40,
        noClick: 41
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Action",
      options,
      id: create_fragment.name
    });
  }
  get drag() {
    return this.$$.ctx[37];
  }
  set drag(value) {
    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get select() {
    return this.$$.ctx[38];
  }
  set select(value) {
    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noAction() {
    return this.$$.ctx[39];
  }
  set noAction(value) {
    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleScroll() {
    return this.$$.ctx[0];
  }
  set handleScroll(value) {
    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unselect() {
    return this.$$.ctx[40];
  }
  set unselect(value) {
    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noClick() {
    return this.$$.ctx[41];
  }
  set noClick(value) {
    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Action_default = Action;

// node_modules/@event-calendar/interaction/src/Pointer.svelte
function create_fragment2(ctx) {
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: noop,
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "pointermove",
            /*handlePointerMove*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "scroll",
            /*handleScroll*/
            ctx[0],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function validEvent(jsEvent) {
  return jsEvent.isPrimary && jsEvent.pointerType === "mouse";
}
function instance2($$self, $$props, $$invalidate) {
  let $_iEvents;
  let $slotDuration;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pointer", slots, []);
  let { _iEvents, slotDuration } = getContext("state");
  validate_store(_iEvents, "_iEvents");
  component_subscribe($$self, _iEvents, (value) => $$invalidate(5, $_iEvents = value));
  validate_store(slotDuration, "slotDuration");
  component_subscribe($$self, slotDuration, (value) => $$invalidate(8, $slotDuration = value));
  let x = 0, y = 0;
  function leave(jsEvent) {
    if (validEvent(jsEvent)) {
      removePointerEvent();
    }
  }
  function move() {
    let dayEl = getElementWithPayload(x, y);
    if (dayEl) {
      let { date, resource } = getPayload(dayEl)(x, y);
      if (!$_iEvents[1]) {
        createPointerEvent();
      }
      set_store_value(_iEvents, $_iEvents[1].start = date, $_iEvents);
      set_store_value(_iEvents, $_iEvents[1].end = addDuration(cloneDate(date), $slotDuration), $_iEvents);
      set_store_value(_iEvents, $_iEvents[1].resourceIds = resource ? [resource.id] : [], $_iEvents);
    }
  }
  function handleScroll() {
    move();
  }
  function handlePointerMove(jsEvent) {
    if (validEvent(jsEvent)) {
      x = jsEvent.clientX;
      y = jsEvent.clientY;
      move();
    }
  }
  function createPointerEvent() {
    set_store_value(
      _iEvents,
      $_iEvents[1] = {
        id: "{pointer}",
        title: "",
        display: "pointer",
        extendedProps: {},
        backgroundColor: "transparent"
      },
      $_iEvents
    );
  }
  function removePointerEvent() {
    set_store_value(_iEvents, $_iEvents[1] = null, $_iEvents);
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Pointer> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    addDuration,
    cloneDate,
    getElementWithPayload,
    getPayload,
    _iEvents,
    slotDuration,
    x,
    y,
    leave,
    move,
    handleScroll,
    handlePointerMove,
    createPointerEvent,
    removePointerEvent,
    validEvent,
    $_iEvents,
    $slotDuration
  });
  $$self.$inject_state = ($$props2) => {
    if ("_iEvents" in $$props2)
      $$invalidate(1, _iEvents = $$props2._iEvents);
    if ("slotDuration" in $$props2)
      $$invalidate(2, slotDuration = $$props2.slotDuration);
    if ("x" in $$props2)
      x = $$props2.x;
    if ("y" in $$props2)
      y = $$props2.y;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_iEvents*/
    32) {
      $:
        if ($_iEvents[0]) {
          removePointerEvent();
        }
    }
  };
  return [handleScroll, _iEvents, slotDuration, handlePointerMove, leave, $_iEvents];
}
var Pointer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { leave: 4, handleScroll: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pointer",
      options,
      id: create_fragment2.name
    });
  }
  get leave() {
    return this.$$.ctx[4];
  }
  set leave(value) {
    throw new Error("<Pointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleScroll() {
    return this.$$.ctx[0];
  }
  set handleScroll(value) {
    throw new Error("<Pointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pointer_default = Pointer;

// node_modules/@event-calendar/interaction/src/Resizer.svelte
var file = "node_modules/@event-calendar/interaction/src/Resizer.svelte";
function create_if_block(ctx) {
  let div;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].resizer);
      add_location(div, file, 17, 4, 463);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "pointerdown",
          /*pointerdown_handler*/
          ctx[8],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].resizer)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(17:0) {#if resizable}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let if_block_anchor;
  let if_block = (
    /*resizable*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*resizable*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $editable;
  let $eventDurationEditable;
  let $theme;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Resizer", slots, []);
  let { event } = $$props;
  let { theme, eventDurationEditable, editable } = getContext("state");
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  validate_store(eventDurationEditable, "eventDurationEditable");
  component_subscribe($$self, eventDurationEditable, (value) => $$invalidate(7, $eventDurationEditable = value));
  validate_store(editable, "editable");
  component_subscribe($$self, editable, (value) => $$invalidate(6, $editable = value));
  let resizable;
  $$self.$$.on_mount.push(function() {
    if (event === void 0 && !("event" in $$props || $$self.$$.bound[$$self.$$.props["event"]])) {
      console.warn("<Resizer> was created without expected prop 'event'");
    }
  });
  const writable_props = ["event"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Resizer> was created with unknown prop '${key}'`);
  });
  function pointerdown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$props2) => {
    if ("event" in $$props2)
      $$invalidate(5, event = $$props2.event);
  };
  $$self.$capture_state = () => ({
    getContext,
    bgEvent,
    helperEvent,
    event,
    theme,
    eventDurationEditable,
    editable,
    resizable,
    $editable,
    $eventDurationEditable,
    $theme
  });
  $$self.$inject_state = ($$props2) => {
    if ("event" in $$props2)
      $$invalidate(5, event = $$props2.event);
    if ("theme" in $$props2)
      $$invalidate(2, theme = $$props2.theme);
    if ("eventDurationEditable" in $$props2)
      $$invalidate(3, eventDurationEditable = $$props2.eventDurationEditable);
    if ("editable" in $$props2)
      $$invalidate(4, editable = $$props2.editable);
    if ("resizable" in $$props2)
      $$invalidate(0, resizable = $$props2.resizable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*event, $eventDurationEditable, $editable*/
    224) {
      $:
        $$invalidate(0, resizable = !bgEvent(event.display) && !helperEvent(event.display) && ((event.durationEditable ?? $eventDurationEditable) || (event.editable ?? $editable)));
    }
  };
  return [
    resizable,
    $theme,
    theme,
    eventDurationEditable,
    editable,
    event,
    $editable,
    $eventDurationEditable,
    pointerdown_handler
  ];
}
var Resizer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { event: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Resizer",
      options,
      id: create_fragment3.name
    });
  }
  get event() {
    throw new Error("<Resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set event(value) {
    throw new Error("<Resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Resizer_default = Resizer;

// node_modules/@event-calendar/interaction/src/Auxiliary.svelte
var { Object: Object_1 } = globals;
function create_if_block2(ctx) {
  let pointer_1;
  let current;
  let pointer_1_props = {};
  pointer_1 = new Pointer_default({ props: pointer_1_props, $$inline: true });
  ctx[16](pointer_1);
  const block = {
    c: function create() {
      create_component(pointer_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(pointer_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(pointer_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const pointer_1_changes = {};
      pointer_1.$set(pointer_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pointer_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pointer_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[16](null);
      destroy_component(pointer_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(33:0) {#if $pointer}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let action;
  let t;
  let if_block_anchor;
  let current;
  let action_props = {};
  action = new Action_default({ props: action_props, $$inline: true });
  ctx[15](action);
  let if_block = (
    /*$pointer*/
    ctx[1] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      create_component(action.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(action.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(action, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const action_changes = {};
      action.$set(action_changes);
      if (
        /*$pointer*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$pointer*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(action.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(action.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      ctx[15](null);
      destroy_component(action, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $_interaction;
  let $_bodyEl;
  let $theme;
  let $_draggable;
  let $_iClasses;
  let $editable;
  let $eventStartEditable;
  let $pointer;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Auxiliary", slots, []);
  let { theme, editable, eventStartEditable, eventDurationEditable, pointer, _bodyEl, _interaction, _iClasses, _draggable } = getContext("state");
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(11, $theme = value));
  validate_store(editable, "editable");
  component_subscribe($$self, editable, (value) => $$invalidate(13, $editable = value));
  validate_store(eventStartEditable, "eventStartEditable");
  component_subscribe($$self, eventStartEditable, (value) => $$invalidate(14, $eventStartEditable = value));
  validate_store(pointer, "pointer");
  component_subscribe($$self, pointer, (value) => $$invalidate(1, $pointer = value));
  validate_store(_bodyEl, "_bodyEl");
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(10, $_bodyEl = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(0, $_interaction = value));
  validate_store(_iClasses, "_iClasses");
  component_subscribe($$self, _iClasses, (value) => $$invalidate(17, $_iClasses = value));
  validate_store(_draggable, "_draggable");
  component_subscribe($$self, _draggable, (value) => $$invalidate(12, $_draggable = value));
  set_store_value(_interaction, $_interaction.resizer = Resizer_default, $_interaction);
  function bodyScrollHandler() {
    var _a;
    for (let component of Object.values($_interaction)) {
      (_a = component == null ? void 0 : component.handleScroll) == null ? void 0 : _a.call(component);
    }
  }
  const writable_props = [];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Auxiliary> was created with unknown prop '${key}'`);
  });
  function action_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $_interaction.action = $$value;
      _interaction.set($_interaction);
    });
  }
  function pointer_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $_interaction.pointer = $$value;
      _interaction.set($_interaction);
    });
  }
  $$self.$capture_state = () => ({
    getContext,
    listen,
    bgEvent,
    helperEvent,
    Action: Action_default,
    Pointer: Pointer_default,
    Resizer: Resizer_default,
    theme,
    editable,
    eventStartEditable,
    eventDurationEditable,
    pointer,
    _bodyEl,
    _interaction,
    _iClasses,
    _draggable,
    bodyScrollHandler,
    $_interaction,
    $_bodyEl,
    $theme,
    $_draggable,
    $_iClasses,
    $editable,
    $eventStartEditable,
    $pointer
  });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(2, theme = $$props2.theme);
    if ("editable" in $$props2)
      $$invalidate(3, editable = $$props2.editable);
    if ("eventStartEditable" in $$props2)
      $$invalidate(4, eventStartEditable = $$props2.eventStartEditable);
    if ("eventDurationEditable" in $$props2)
      eventDurationEditable = $$props2.eventDurationEditable;
    if ("pointer" in $$props2)
      $$invalidate(5, pointer = $$props2.pointer);
    if ("_bodyEl" in $$props2)
      $$invalidate(6, _bodyEl = $$props2._bodyEl);
    if ("_interaction" in $$props2)
      $$invalidate(7, _interaction = $$props2._interaction);
    if ("_iClasses" in $$props2)
      $$invalidate(8, _iClasses = $$props2._iClasses);
    if ("_draggable" in $$props2)
      $$invalidate(9, _draggable = $$props2._draggable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$eventStartEditable, $editable*/
    24576) {
      $:
        set_store_value(_draggable, $_draggable = (event) => (event.startEditable ?? $eventStartEditable) || (event.editable ?? $editable), $_draggable);
    }
    if ($$self.$$.dirty & /*$theme, $_draggable*/
    6144) {
      $:
        set_store_value(
          _iClasses,
          $_iClasses = (className, event) => {
            let { display } = event;
            return helperEvent(display) ? [$theme[display]] : !bgEvent(display) && $_draggable(event) ? [$theme.draggable] : [];
          },
          $_iClasses
        );
    }
    if ($$self.$$.dirty & /*$_bodyEl*/
    1024) {
      $:
        if ($_bodyEl) {
          listen($_bodyEl, "scroll", bodyScrollHandler);
        }
    }
  };
  return [
    $_interaction,
    $pointer,
    theme,
    editable,
    eventStartEditable,
    pointer,
    _bodyEl,
    _interaction,
    _iClasses,
    _draggable,
    $_bodyEl,
    $theme,
    $_draggable,
    $editable,
    $eventStartEditable,
    action_binding,
    pointer_1_binding
  ];
}
var Auxiliary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Auxiliary",
      options,
      id: create_fragment4.name
    });
  }
};
var Auxiliary_default = Auxiliary;

// node_modules/@event-calendar/interaction/src/index.js
var src_default = {
  createOptions(options) {
    options.dateClick = void 0;
    options.dragScroll = true;
    options.editable = false;
    options.eventDragMinDistance = 5;
    options.eventDragStart = void 0;
    options.eventDragStop = void 0;
    options.eventDrop = void 0;
    options.eventDurationEditable = true;
    options.eventLongPressDelay = void 0;
    options.eventResizeStart = void 0;
    options.eventResizeStop = void 0;
    options.eventResize = void 0;
    options.eventStartEditable = true;
    options.longPressDelay = 1e3;
    options.pointer = false;
    options.select = void 0;
    options.selectBackgroundColor = void 0;
    options.selectLongPressDelay = void 0;
    options.selectMinDistance = 5;
    options.unselect = void 0;
    options.unselectAuto = true;
    options.unselectCancel = "";
    options.theme.draggable = "ec-draggable";
    options.theme.ghost = "ec-ghost";
    options.theme.preview = "ec-preview";
    options.theme.pointer = "ec-pointer";
    options.theme.resizer = "ec-resizer";
    options.theme.dragging = "ec-dragging";
    options.theme.resizingY = "ec-resizing-y";
    options.theme.resizingX = "ec-resizing-x";
    options.theme.selecting = "ec-selecting";
  },
  createStores(state) {
    state._draggable = writable(noop);
    state._auxiliary.update(($_auxiliary) => [...$_auxiliary, Auxiliary_default]);
  }
};
export {
  src_default as default
};
//# sourceMappingURL=@event-calendar_interaction.js.map
