import {
  addDay,
  bgEvent,
  btnTextDay,
  btnTextMonth,
  btnTextWeek,
  btnTextYear,
  cloneDate,
  createEventChunk,
  createEventClasses,
  createEventContent,
  datesEqual,
  eventIntersects,
  intl,
  keyEnter,
  setContent,
  setPayload,
  sortEventChunks,
  task,
  themeView,
  toEventWithLocalDates,
  toISOString,
  toViewWithLocalDates
} from "./chunk-7NNYD6EP.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-TE5TN4QG.js";
import "./chunk-ZDKSVB7X.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  append_hydration_dev,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  getContext,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  space,
  transition_in,
  transition_out,
  update_keyed_each,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-CBQLSORC.js";
import "./chunk-GZA2YTNP.js";
import "./chunk-LNEMQRCO.js";

// node_modules/@event-calendar/list/src/Event.svelte
var file = "node_modules/@event-calendar/list/src/Event.svelte";
function create_fragment(ctx) {
  let article;
  let div0;
  let div0_class_value;
  let t;
  let div1;
  let div1_class_value;
  let setContent_action;
  let article_role_value;
  let article_tabindex_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      article = element("article");
      div0 = element("div");
      t = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      article = claim_element(nodes, "ARTICLE", { class: true, role: true, tabindex: true });
      var article_nodes = children(article);
      div0 = claim_element(article_nodes, "DIV", { class: true, style: true });
      children(div0).forEach(detach_dev);
      t = claim_space(article_nodes);
      div1 = claim_element(article_nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      article_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[0].eventTag);
      attr_dev(
        div0,
        "style",
        /*style*/
        ctx[3]
      );
      add_location(div0, file, 91, 4, 2683);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[0].eventBody);
      add_location(div1, file, 92, 4, 2733);
      attr_dev(
        article,
        "class",
        /*classes*/
        ctx[2]
      );
      attr_dev(article, "role", article_role_value = /*onclick*/
      ctx[5] ? "button" : void 0);
      attr_dev(article, "tabindex", article_tabindex_value = /*onclick*/
      ctx[5] ? 0 : void 0);
      add_location(article, file, 80, 0, 2317);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, article, anchor);
      append_hydration_dev(article, div0);
      append_hydration_dev(article, t);
      append_hydration_dev(article, div1);
      ctx[40](article);
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            div1,
            /*content*/
            ctx[4]
          )),
          listen_dev(
            article,
            "click",
            function() {
              if (is_function(
                /*onclick*/
                ctx[5]
              ))
                ctx[5].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            article,
            "keydown",
            function() {
              if (is_function(
                /*onclick*/
                ctx[5] && keyEnter(
                  /*onclick*/
                  ctx[5]
                )
              ))
                /*onclick*/
                (ctx[5] && keyEnter(
                  /*onclick*/
                  ctx[5]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            article,
            "mouseenter",
            function() {
              if (is_function(
                /*createHandler*/
                ctx[26](
                  /*$eventMouseEnter*/
                  ctx[6]
                )
              ))
                ctx[26](
                  /*$eventMouseEnter*/
                  ctx[6]
                ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            article,
            "mouseleave",
            function() {
              if (is_function(
                /*createHandler*/
                ctx[26](
                  /*$eventMouseLeave*/
                  ctx[7]
                )
              ))
                ctx[26](
                  /*$eventMouseLeave*/
                  ctx[7]
                ).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            article,
            "pointerdown",
            function() {
              var _a, _b;
              if (is_function(
                /*$_interaction*/
                (_a = ctx[8].action) == null ? void 0 : _a.noAction
              ))
                (_b = ctx[8].action) == null ? void 0 : _b.noAction.apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*$theme*/
      1 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx[0].eventTag)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty[0] & /*style*/
      8) {
        attr_dev(
          div0,
          "style",
          /*style*/
          ctx[3]
        );
      }
      if (dirty[0] & /*$theme*/
      1 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx[0].eventBody)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/
      16)
        setContent_action.update.call(
          null,
          /*content*/
          ctx[4]
        );
      if (dirty[0] & /*classes*/
      4) {
        attr_dev(
          article,
          "class",
          /*classes*/
          ctx[2]
        );
      }
      if (dirty[0] & /*onclick*/
      32 && article_role_value !== (article_role_value = /*onclick*/
      ctx[5] ? "button" : void 0)) {
        attr_dev(article, "role", article_role_value);
      }
      if (dirty[0] & /*onclick*/
      32 && article_tabindex_value !== (article_tabindex_value = /*onclick*/
      ctx[5] ? 0 : void 0)) {
        attr_dev(article, "tabindex", article_tabindex_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(article);
      }
      ctx[40](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $eventClick;
  let $_view;
  let $eventAllUpdated;
  let $eventDidMount;
  let $_intlEventTime;
  let $theme;
  let $eventContent;
  let $displayEventEnd;
  let $eventClassNames;
  let $eventTextColor;
  let $_resTxtColor;
  let $eventColor;
  let $eventBackgroundColor;
  let $_resBgColor;
  let $eventMouseEnter;
  let $eventMouseLeave;
  let $_interaction;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Event", slots, []);
  let { chunk } = $$props;
  let { displayEventEnd, eventAllUpdated, eventBackgroundColor, eventTextColor, eventColor, eventContent, eventClassNames, eventClick, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _resBgColor, _resTxtColor, _interaction, _tasks } = getContext("state");
  validate_store(displayEventEnd, "displayEventEnd");
  component_subscribe($$self, displayEventEnd, (value) => $$invalidate(33, $displayEventEnd = value));
  validate_store(eventAllUpdated, "eventAllUpdated");
  component_subscribe($$self, eventAllUpdated, (value) => $$invalidate(42, $eventAllUpdated = value));
  validate_store(eventBackgroundColor, "eventBackgroundColor");
  component_subscribe($$self, eventBackgroundColor, (value) => $$invalidate(38, $eventBackgroundColor = value));
  validate_store(eventTextColor, "eventTextColor");
  component_subscribe($$self, eventTextColor, (value) => $$invalidate(35, $eventTextColor = value));
  validate_store(eventColor, "eventColor");
  component_subscribe($$self, eventColor, (value) => $$invalidate(37, $eventColor = value));
  validate_store(eventContent, "eventContent");
  component_subscribe($$self, eventContent, (value) => $$invalidate(32, $eventContent = value));
  validate_store(eventClassNames, "eventClassNames");
  component_subscribe($$self, eventClassNames, (value) => $$invalidate(34, $eventClassNames = value));
  validate_store(eventClick, "eventClick");
  component_subscribe($$self, eventClick, (value) => $$invalidate(29, $eventClick = value));
  validate_store(eventDidMount, "eventDidMount");
  component_subscribe($$self, eventDidMount, (value) => $$invalidate(43, $eventDidMount = value));
  validate_store(eventMouseEnter, "eventMouseEnter");
  component_subscribe($$self, eventMouseEnter, (value) => $$invalidate(6, $eventMouseEnter = value));
  validate_store(eventMouseLeave, "eventMouseLeave");
  component_subscribe($$self, eventMouseLeave, (value) => $$invalidate(7, $eventMouseLeave = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(0, $theme = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(30, $_view = value));
  validate_store(_intlEventTime, "_intlEventTime");
  component_subscribe($$self, _intlEventTime, (value) => $$invalidate(31, $_intlEventTime = value));
  validate_store(_resBgColor, "_resBgColor");
  component_subscribe($$self, _resBgColor, (value) => $$invalidate(39, $_resBgColor = value));
  validate_store(_resTxtColor, "_resTxtColor");
  component_subscribe($$self, _resTxtColor, (value) => $$invalidate(36, $_resTxtColor = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(8, $_interaction = value));
  let el;
  let event;
  let classes;
  let style;
  let content;
  let timeText;
  let onclick;
  onMount(() => {
    if (is_function($eventDidMount)) {
      $eventDidMount({
        event: toEventWithLocalDates(event),
        timeText,
        el,
        view: toViewWithLocalDates($_view)
      });
    }
  });
  afterUpdate(() => {
    if (is_function($eventAllUpdated)) {
      task(() => $eventAllUpdated({ view: toViewWithLocalDates($_view) }), "eau", _tasks);
    }
  });
  function createHandler(fn) {
    return is_function(fn) ? (jsEvent) => fn({
      event: toEventWithLocalDates(event),
      el,
      jsEvent,
      view: toViewWithLocalDates($_view)
    }) : void 0;
  }
  $$self.$$.on_mount.push(function() {
    if (chunk === void 0 && !("chunk" in $$props || $$self.$$.bound[$$self.$$.props["chunk"]])) {
      console.warn("<Event> was created without expected prop 'chunk'");
    }
  });
  const writable_props = ["chunk"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Event> was created with unknown prop '${key}'`);
  });
  function article_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("chunk" in $$props2)
      $$invalidate(27, chunk = $$props2.chunk);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    getContext,
    onMount,
    is_function,
    createEventContent,
    toEventWithLocalDates,
    toViewWithLocalDates,
    setContent,
    createEventClasses,
    keyEnter,
    task,
    chunk,
    displayEventEnd,
    eventAllUpdated,
    eventBackgroundColor,
    eventTextColor,
    eventColor,
    eventContent,
    eventClassNames,
    eventClick,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    theme,
    _view,
    _intlEventTime,
    _resBgColor,
    _resTxtColor,
    _interaction,
    _tasks,
    el,
    event,
    classes,
    style,
    content,
    timeText,
    onclick,
    createHandler,
    $eventClick,
    $_view,
    $eventAllUpdated,
    $eventDidMount,
    $_intlEventTime,
    $theme,
    $eventContent,
    $displayEventEnd,
    $eventClassNames,
    $eventTextColor,
    $_resTxtColor,
    $eventColor,
    $eventBackgroundColor,
    $_resBgColor,
    $eventMouseEnter,
    $eventMouseLeave,
    $_interaction
  });
  $$self.$inject_state = ($$props2) => {
    if ("chunk" in $$props2)
      $$invalidate(27, chunk = $$props2.chunk);
    if ("displayEventEnd" in $$props2)
      $$invalidate(9, displayEventEnd = $$props2.displayEventEnd);
    if ("eventAllUpdated" in $$props2)
      $$invalidate(10, eventAllUpdated = $$props2.eventAllUpdated);
    if ("eventBackgroundColor" in $$props2)
      $$invalidate(11, eventBackgroundColor = $$props2.eventBackgroundColor);
    if ("eventTextColor" in $$props2)
      $$invalidate(12, eventTextColor = $$props2.eventTextColor);
    if ("eventColor" in $$props2)
      $$invalidate(13, eventColor = $$props2.eventColor);
    if ("eventContent" in $$props2)
      $$invalidate(14, eventContent = $$props2.eventContent);
    if ("eventClassNames" in $$props2)
      $$invalidate(15, eventClassNames = $$props2.eventClassNames);
    if ("eventClick" in $$props2)
      $$invalidate(16, eventClick = $$props2.eventClick);
    if ("eventDidMount" in $$props2)
      $$invalidate(17, eventDidMount = $$props2.eventDidMount);
    if ("eventMouseEnter" in $$props2)
      $$invalidate(18, eventMouseEnter = $$props2.eventMouseEnter);
    if ("eventMouseLeave" in $$props2)
      $$invalidate(19, eventMouseLeave = $$props2.eventMouseLeave);
    if ("theme" in $$props2)
      $$invalidate(20, theme = $$props2.theme);
    if ("_view" in $$props2)
      $$invalidate(21, _view = $$props2._view);
    if ("_intlEventTime" in $$props2)
      $$invalidate(22, _intlEventTime = $$props2._intlEventTime);
    if ("_resBgColor" in $$props2)
      $$invalidate(23, _resBgColor = $$props2._resBgColor);
    if ("_resTxtColor" in $$props2)
      $$invalidate(24, _resTxtColor = $$props2._resTxtColor);
    if ("_interaction" in $$props2)
      $$invalidate(25, _interaction = $$props2._interaction);
    if ("_tasks" in $$props2)
      _tasks = $$props2._tasks;
    if ("el" in $$props2)
      $$invalidate(1, el = $$props2.el);
    if ("event" in $$props2)
      $$invalidate(28, event = $$props2.event);
    if ("classes" in $$props2)
      $$invalidate(2, classes = $$props2.classes);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("content" in $$props2)
      $$invalidate(4, content = $$props2.content);
    if ("timeText" in $$props2)
      timeText = $$props2.timeText;
    if ("onclick" in $$props2)
      $$invalidate(5, onclick = $$props2.onclick);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*chunk*/
    134217728) {
      $:
        $$invalidate(28, event = chunk.event);
    }
    if ($$self.$$.dirty[0] & /*event, style, $theme, $_view*/
    1342177289 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, $eventClassNames*/
    504) {
      $: {
        $$invalidate(3, style = "");
        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
        if (bgColor) {
          $$invalidate(3, style = `background-color:${bgColor};`);
        }
        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
        if (txtColor) {
          $$invalidate(3, style += `color:${txtColor};`);
        }
        $$invalidate(2, classes = [$theme.event, ...createEventClasses($eventClassNames, event, $_view)].join(" "));
      }
    }
    if ($$self.$$.dirty[0] & /*chunk, $theme, $_view*/
    1207959553 | $$self.$$.dirty[1] & /*$displayEventEnd, $eventContent, $_intlEventTime*/
    7) {
      $: {
        $$invalidate(4, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
      }
    }
    if ($$self.$$.dirty[0] & /*$eventClick*/
    536870912) {
      $:
        $$invalidate(5, onclick = createHandler($eventClick));
    }
  };
  return [
    $theme,
    el,
    classes,
    style,
    content,
    onclick,
    $eventMouseEnter,
    $eventMouseLeave,
    $_interaction,
    displayEventEnd,
    eventAllUpdated,
    eventBackgroundColor,
    eventTextColor,
    eventColor,
    eventContent,
    eventClassNames,
    eventClick,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    theme,
    _view,
    _intlEventTime,
    _resBgColor,
    _resTxtColor,
    _interaction,
    createHandler,
    chunk,
    event,
    $eventClick,
    $_view,
    $_intlEventTime,
    $eventContent,
    $displayEventEnd,
    $eventClassNames,
    $eventTextColor,
    $_resTxtColor,
    $eventColor,
    $eventBackgroundColor,
    $_resBgColor,
    article_binding
  ];
}
var Event = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { chunk: 27 }, null, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Event",
      options,
      id: create_fragment.name
    });
  }
  get chunk() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chunk(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Event_default = Event;

// node_modules/@event-calendar/list/src/Day.svelte
var file2 = "node_modules/@event-calendar/list/src/Day.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let div;
  let h4;
  let time0;
  let setContent_action;
  let t0;
  let time1;
  let time1_class_value;
  let setContent_action_1;
  let h4_class_value;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*chunks*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*chunk*/
    ctx2[21].event
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      h4 = element("h4");
      time0 = element("time");
      t0 = space();
      time1 = element("time");
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      h4 = claim_element(div_nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      time0 = claim_element(h4_nodes, "TIME", { datetime: true });
      children(time0).forEach(detach_dev);
      t0 = claim_space(h4_nodes);
      time1 = claim_element(h4_nodes, "TIME", { class: true, datetime: true });
      children(time1).forEach(detach_dev);
      h4_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(
        time0,
        "datetime",
        /*datetime*/
        ctx[5]
      );
      add_location(time0, file2, 56, 12, 1571);
      attr_dev(time1, "class", time1_class_value = /*$theme*/
      ctx[6].daySide);
      attr_dev(
        time1,
        "datetime",
        /*datetime*/
        ctx[5]
      );
      add_location(time1, file2, 57, 12, 1652);
      attr_dev(h4, "class", h4_class_value = /*$theme*/
      ctx[6].dayHead);
      add_location(h4, file2, 55, 8, 1529);
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[6].day + " " + /*$theme*/
      ((_a = ctx[6].weekdays) == null ? void 0 : _a[
        /*date*/
        ctx[0].getUTCDay()
      ]) + /*isToday*/
      (ctx[3] ? " " + /*$theme*/
      ctx[6].today : "") + /*highlight*/
      (ctx[4] ? " " + /*$theme*/
      ctx[6].highlight : ""));
      attr_dev(div, "role", "listitem");
      add_location(div, file2, 49, 4, 1266);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h4);
      append_hydration_dev(h4, time0);
      append_hydration_dev(h4, t0);
      append_hydration_dev(h4, time1);
      append_hydration_dev(div, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[20](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            time0,
            /*$_intlListDay*/
            ctx[8].format(
              /*date*/
              ctx[0]
            )
          )),
          action_destroyer(setContent_action_1 = setContent.call(
            null,
            time1,
            /*$_intlListDaySide*/
            ctx[9].format(
              /*date*/
              ctx[0]
            )
          )),
          listen_dev(
            div,
            "pointerdown",
            function() {
              var _a, _b;
              if (is_function(
                /*$_interaction*/
                (_a = ctx[7].action) == null ? void 0 : _a.select
              ))
                (_b = ctx[7].action) == null ? void 0 : _b.select.apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (!current || dirty & /*datetime*/
      32) {
        attr_dev(
          time0,
          "datetime",
          /*datetime*/
          ctx[5]
        );
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlListDay, date*/
      257)
        setContent_action.update.call(
          null,
          /*$_intlListDay*/
          ctx[8].format(
            /*date*/
            ctx[0]
          )
        );
      if (!current || dirty & /*$theme*/
      64 && time1_class_value !== (time1_class_value = /*$theme*/
      ctx[6].daySide)) {
        attr_dev(time1, "class", time1_class_value);
      }
      if (!current || dirty & /*datetime*/
      32) {
        attr_dev(
          time1,
          "datetime",
          /*datetime*/
          ctx[5]
        );
      }
      if (setContent_action_1 && is_function(setContent_action_1.update) && dirty & /*$_intlListDaySide, date*/
      513)
        setContent_action_1.update.call(
          null,
          /*$_intlListDaySide*/
          ctx[9].format(
            /*date*/
            ctx[0]
          )
        );
      if (!current || dirty & /*$theme*/
      64 && h4_class_value !== (h4_class_value = /*$theme*/
      ctx[6].dayHead)) {
        attr_dev(h4, "class", h4_class_value);
      }
      if (dirty & /*chunks*/
      4) {
        each_value = ensure_array_like_dev(
          /*chunks*/
          ctx[2]
        );
        group_outros();
        validate_each_keys(ctx, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty & /*$theme, date, isToday, highlight*/
      89 && div_class_value !== (div_class_value = /*$theme*/
      ctx[6].day + " " + /*$theme*/
      ((_a = ctx[6].weekdays) == null ? void 0 : _a[
        /*date*/
        ctx[0].getUTCDay()
      ]) + /*isToday*/
      (ctx[3] ? " " + /*$theme*/
      ctx[6].today : "") + /*highlight*/
      (ctx[4] ? " " + /*$theme*/
      ctx[6].highlight : ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(49:0) {#if chunks.length}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let event;
  let current;
  event = new Event_default({
    props: { chunk: (
      /*chunk*/
      ctx[21]
    ) },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(event.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const event_changes = {};
      if (dirty & /*chunks*/
      4)
        event_changes.chunk = /*chunk*/
        ctx[21];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(60:8) {#each chunks as chunk (chunk.event)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*chunks*/
    ctx[2].length && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*chunks*/
        ctx2[2].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*chunks*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $highlightedDates;
  let $_today;
  let $_events;
  let $theme;
  let $_interaction;
  let $_intlListDay;
  let $_intlListDaySide;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Day", slots, []);
  let { date } = $$props;
  let { _events, _interaction, _intlListDay, _intlListDaySide, _today, highlightedDates, theme } = getContext("state");
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(19, $_events = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(7, $_interaction = value));
  validate_store(_intlListDay, "_intlListDay");
  component_subscribe($$self, _intlListDay, (value) => $$invalidate(8, $_intlListDay = value));
  validate_store(_intlListDaySide, "_intlListDaySide");
  component_subscribe($$self, _intlListDaySide, (value) => $$invalidate(9, $_intlListDaySide = value));
  validate_store(_today, "_today");
  component_subscribe($$self, _today, (value) => $$invalidate(18, $_today = value));
  validate_store(highlightedDates, "highlightedDates");
  component_subscribe($$self, highlightedDates, (value) => $$invalidate(17, $highlightedDates = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(6, $theme = value));
  let el;
  let chunks;
  let isToday, highlight;
  let datetime;
  $$self.$$.on_mount.push(function() {
    if (date === void 0 && !("date" in $$props || $$self.$$.bound[$$self.$$.props["date"]])) {
      console.warn("<Day> was created without expected prop 'date'");
    }
  });
  const writable_props = ["date"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Day> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
  };
  $$self.$capture_state = () => ({
    getContext,
    addDay,
    cloneDate,
    createEventChunk,
    datesEqual,
    sortEventChunks,
    eventIntersects,
    setContent,
    setPayload,
    bgEvent,
    toISOString,
    Event: Event_default,
    date,
    _events,
    _interaction,
    _intlListDay,
    _intlListDaySide,
    _today,
    highlightedDates,
    theme,
    el,
    chunks,
    isToday,
    highlight,
    datetime,
    $highlightedDates,
    $_today,
    $_events,
    $theme,
    $_interaction,
    $_intlListDay,
    $_intlListDaySide
  });
  $$self.$inject_state = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("_events" in $$props2)
      $$invalidate(10, _events = $$props2._events);
    if ("_interaction" in $$props2)
      $$invalidate(11, _interaction = $$props2._interaction);
    if ("_intlListDay" in $$props2)
      $$invalidate(12, _intlListDay = $$props2._intlListDay);
    if ("_intlListDaySide" in $$props2)
      $$invalidate(13, _intlListDaySide = $$props2._intlListDaySide);
    if ("_today" in $$props2)
      $$invalidate(14, _today = $$props2._today);
    if ("highlightedDates" in $$props2)
      $$invalidate(15, highlightedDates = $$props2.highlightedDates);
    if ("theme" in $$props2)
      $$invalidate(16, theme = $$props2.theme);
    if ("el" in $$props2)
      $$invalidate(1, el = $$props2.el);
    if ("chunks" in $$props2)
      $$invalidate(2, chunks = $$props2.chunks);
    if ("isToday" in $$props2)
      $$invalidate(3, isToday = $$props2.isToday);
    if ("highlight" in $$props2)
      $$invalidate(4, highlight = $$props2.highlight);
    if ("datetime" in $$props2)
      $$invalidate(5, datetime = $$props2.datetime);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*date, $_events, chunks*/
    524293) {
      $: {
        $$invalidate(2, chunks = []);
        let start = date;
        let end = addDay(cloneDate(date));
        for (let event of $_events) {
          if (!bgEvent(event.display) && eventIntersects(event, start, end)) {
            let chunk = createEventChunk(event, start, end);
            chunks.push(chunk);
          }
        }
        sortEventChunks(chunks);
      }
    }
    if ($$self.$$.dirty & /*date, $_today*/
    262145) {
      $:
        $$invalidate(3, isToday = datesEqual(date, $_today));
    }
    if ($$self.$$.dirty & /*$highlightedDates, date*/
    131073) {
      $:
        $$invalidate(4, highlight = $highlightedDates.some((d) => datesEqual(d, date)));
    }
    if ($$self.$$.dirty & /*date*/
    1) {
      $:
        $$invalidate(5, datetime = toISOString(date, 10));
    }
    if ($$self.$$.dirty & /*el, date*/
    3) {
      $:
        if (el) {
          setPayload(el, () => ({
            allDay: true,
            date,
            resource: void 0,
            dayEl: el
          }));
        }
    }
  };
  return [
    date,
    el,
    chunks,
    isToday,
    highlight,
    datetime,
    $theme,
    $_interaction,
    $_intlListDay,
    $_intlListDaySide,
    _events,
    _interaction,
    _intlListDay,
    _intlListDaySide,
    _today,
    highlightedDates,
    theme,
    $highlightedDates,
    $_today,
    $_events,
    div_binding
  ];
}
var Day = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { date: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Day",
      options,
      id: create_fragment2.name
    });
  }
  get date() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set date(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Day_default = Day;

// node_modules/@event-calendar/list/src/Body.svelte
var file3 = "node_modules/@event-calendar/list/src/Body.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*$_viewDates*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_viewDates*/
      2) {
        each_value = ensure_array_like_dev(
          /*$_viewDates*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(45:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let div_class_value;
  let setContent_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[3].noEvents);
      add_location(div, file3, 43, 12, 1442);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            div,
            /*content*/
            ctx[0]
          )),
          listen_dev(
            div,
            "click",
            /*handleClick*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme*/
      8 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[3].noEvents)) {
        attr_dev(div, "class", div_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*content*/
      1)
        setContent_action.update.call(
          null,
          /*content*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(41:8) {#if noEvents}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let day;
  let current;
  day = new Day_default({
    props: { date: (
      /*date*/
      ctx[18]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(day.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(day.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(day, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const day_changes = {};
      if (dirty & /*$_viewDates*/
      2)
        day_changes.date = /*date*/
        ctx2[18];
      day.$set(day_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(day.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(day.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(day, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(46:12) {#each $_viewDates as date}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let div0_class_value;
  let div1_class_value;
  let current;
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noEvents*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[3].content);
      add_location(div0, file3, 39, 4, 1236);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[3].body);
      add_location(div1, file3, 38, 0, 1183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      ctx[15](div1);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      if (!current || dirty & /*$theme*/
      8 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx2[3].content)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*$theme*/
      8 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx2[3].body)) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if_blocks[current_block_type_index].d();
      ctx[15](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $_view;
  let $noEventsClick;
  let $noEventsContent;
  let $_events;
  let $_viewDates;
  let $theme;
  let $_bodyEl;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Body", slots, []);
  let { _bodyEl, _events, _view, _viewDates, noEventsClick, noEventsContent, theme } = getContext("state");
  validate_store(_bodyEl, "_bodyEl");
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(4, $_bodyEl = value));
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(14, $_events = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(16, $_view = value));
  validate_store(_viewDates, "_viewDates");
  component_subscribe($$self, _viewDates, (value) => $$invalidate(1, $_viewDates = value));
  validate_store(noEventsClick, "noEventsClick");
  component_subscribe($$self, noEventsClick, (value) => $$invalidate(17, $noEventsClick = value));
  validate_store(noEventsContent, "noEventsContent");
  component_subscribe($$self, noEventsContent, (value) => $$invalidate(13, $noEventsContent = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(3, $theme = value));
  let noEvents, content;
  function handleClick(jsEvent) {
    if (is_function($noEventsClick)) {
      $noEventsClick({
        jsEvent,
        view: toViewWithLocalDates($_view)
      });
    }
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Body> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $_bodyEl = $$value;
      _bodyEl.set($_bodyEl);
    });
  }
  $$self.$capture_state = () => ({
    getContext,
    is_function,
    addDay,
    cloneDate,
    toViewWithLocalDates,
    setContent,
    bgEvent,
    Day: Day_default,
    _bodyEl,
    _events,
    _view,
    _viewDates,
    noEventsClick,
    noEventsContent,
    theme,
    noEvents,
    content,
    handleClick,
    $_view,
    $noEventsClick,
    $noEventsContent,
    $_events,
    $_viewDates,
    $theme,
    $_bodyEl
  });
  $$self.$inject_state = ($$props2) => {
    if ("_bodyEl" in $$props2)
      $$invalidate(5, _bodyEl = $$props2._bodyEl);
    if ("_events" in $$props2)
      $$invalidate(6, _events = $$props2._events);
    if ("_view" in $$props2)
      $$invalidate(7, _view = $$props2._view);
    if ("_viewDates" in $$props2)
      $$invalidate(8, _viewDates = $$props2._viewDates);
    if ("noEventsClick" in $$props2)
      $$invalidate(9, noEventsClick = $$props2.noEventsClick);
    if ("noEventsContent" in $$props2)
      $$invalidate(10, noEventsContent = $$props2.noEventsContent);
    if ("theme" in $$props2)
      $$invalidate(11, theme = $$props2.theme);
    if ("noEvents" in $$props2)
      $$invalidate(2, noEvents = $$props2.noEvents);
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_viewDates, $_events*/
    16386) {
      $: {
        $$invalidate(2, noEvents = true);
        if ($_viewDates.length) {
          let start = $_viewDates[0];
          let end = addDay(cloneDate($_viewDates[$_viewDates.length - 1]));
          for (let event of $_events) {
            if (!bgEvent(event.display) && event.start < end && event.end > start) {
              $$invalidate(2, noEvents = false);
              break;
            }
          }
        }
      }
    }
    if ($$self.$$.dirty & /*$noEventsContent, content*/
    8193) {
      $: {
        $$invalidate(0, content = is_function($noEventsContent) ? $noEventsContent() : $noEventsContent);
        if (typeof content === "string") {
          $$invalidate(0, content = { html: content });
        }
      }
    }
  };
  return [
    content,
    $_viewDates,
    noEvents,
    $theme,
    $_bodyEl,
    _bodyEl,
    _events,
    _view,
    _viewDates,
    noEventsClick,
    noEventsContent,
    theme,
    handleClick,
    $noEventsContent,
    $_events,
    div1_binding
  ];
}
var Body = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Body",
      options,
      id: create_fragment3.name
    });
  }
};
var Body_default = Body;

// node_modules/@event-calendar/list/src/View.svelte
function create_fragment4(ctx) {
  let body;
  let current;
  body = new Body_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(body.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(body.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(body, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(body.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(body.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(body, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("View", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<View> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ Body: Body_default });
  return [];
}
var View = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "View",
      options,
      id: create_fragment4.name
    });
  }
};
var View_default = View;

// node_modules/@event-calendar/list/src/index.js
var src_default = {
  createOptions(options) {
    options.buttonText.listDay = "list";
    options.buttonText.listWeek = "list";
    options.buttonText.listMonth = "list";
    options.buttonText.listYear = "list";
    options.listDayFormat = { weekday: "long" };
    options.listDaySideFormat = { year: "numeric", month: "long", day: "numeric" };
    options.noEventsClick = void 0;
    options.noEventsContent = "No events";
    options.theme.daySide = "ec-day-side";
    options.theme.eventTag = "ec-event-tag";
    options.theme.noEvents = "ec-no-events";
    options.view = "listWeek";
    options.views.listDay = {
      buttonText: btnTextDay,
      component: View_default,
      duration: { days: 1 },
      theme: themeView("ec-list ec-day-view")
    };
    options.views.listWeek = {
      buttonText: btnTextWeek,
      component: View_default,
      duration: { weeks: 1 },
      theme: themeView("ec-list ec-week-view")
    };
    options.views.listMonth = {
      buttonText: btnTextMonth,
      component: View_default,
      duration: { months: 1 },
      theme: themeView("ec-list ec-month-view")
    };
    options.views.listYear = {
      buttonText: btnTextYear,
      component: View_default,
      duration: { years: 1 },
      theme: themeView("ec-list ec-year-view")
    };
  },
  createStores(state) {
    state._intlListDay = intl(state.locale, state.listDayFormat);
    state._intlListDaySide = intl(state.locale, state.listDaySideFormat);
  }
};
export {
  src_default as default
};
//# sourceMappingURL=@event-calendar_list.js.map
