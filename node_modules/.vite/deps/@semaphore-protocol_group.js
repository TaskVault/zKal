import {
  BigNumber,
  arrayify,
  zeroPad
} from "./chunk-5QR6ED5T.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LNEMQRCO.js";

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@zk-kit/incremental-merkle-tree/dist/index.mjs
function checkParameter(value, name) {
  var types = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    types[_i - 2] = arguments[_i];
  }
  if (value === void 0) {
    throw new TypeError("Parameter '".concat(name, "' is not defined"));
  }
  if (!types.includes(typeof value)) {
    throw new TypeError("Parameter '".concat(name, "' is none of these types: ").concat(types.join(", ")));
  }
}
function createProof(index, depth, arity, nodes, zeroes, root) {
  checkParameter(index, "index", "number");
  if (index < 0 || index >= nodes[0].length) {
    throw new Error("The leaf does not exist in this tree");
  }
  var siblings = [];
  var pathIndices = [];
  var leafIndex = index;
  for (var level = 0; level < depth; level += 1) {
    var position = index % arity;
    var levelStartIndex = index - position;
    var levelEndIndex = levelStartIndex + arity;
    pathIndices[level] = position;
    siblings[level] = [];
    for (var i = levelStartIndex; i < levelEndIndex; i += 1) {
      if (i !== index) {
        if (i < nodes[level].length) {
          siblings[level].push(nodes[level][i]);
        } else {
          siblings[level].push(zeroes[level]);
        }
      }
    }
    index = Math.floor(index / arity);
  }
  return { root, leaf: nodes[0][leafIndex], pathIndices, siblings };
}
function indexOf(leaf, nodes) {
  checkParameter(leaf, "leaf", "number", "string", "bigint");
  return nodes[0].indexOf(leaf);
}
function insert(leaf, depth, arity, nodes, zeroes, hash2) {
  checkParameter(leaf, "leaf", "number", "string", "bigint");
  if (nodes[0].length >= Math.pow(arity, depth)) {
    throw new Error("The tree is full");
  }
  var node = leaf;
  var index = nodes[0].length;
  for (var level = 0; level < depth; level += 1) {
    var position = index % arity;
    var levelStartIndex = index - position;
    var levelEndIndex = levelStartIndex + arity;
    var children = [];
    nodes[level][index] = node;
    for (var i = levelStartIndex; i < levelEndIndex; i += 1) {
      if (i < nodes[level].length) {
        children.push(nodes[level][i]);
      } else {
        children.push(zeroes[level]);
      }
    }
    node = hash2(children);
    index = Math.floor(index / arity);
  }
  return node;
}
function update(index, value, depth, arity, nodes, zeroes, hash2) {
  checkParameter(index, "index", "number");
  if (index < 0 || index >= nodes[0].length) {
    throw new Error("The leaf does not exist in this tree");
  }
  var node = value;
  for (var level = 0; level < depth; level += 1) {
    var position = index % arity;
    var levelStartIndex = index - position;
    var levelEndIndex = levelStartIndex + arity;
    var children = [];
    nodes[level][index] = node;
    for (var i = levelStartIndex; i < levelEndIndex; i += 1) {
      if (i < nodes[level].length) {
        children.push(nodes[level][i]);
      } else {
        children.push(zeroes[level]);
      }
    }
    node = hash2(children);
    index = Math.floor(index / arity);
  }
  return node;
}
function verifyProof(proof, hash2) {
  checkParameter(proof, "proof", "object");
  checkParameter(proof.root, "proof.root", "number", "string", "bigint");
  checkParameter(proof.leaf, "proof.leaf", "number", "string", "bigint");
  checkParameter(proof.siblings, "proof.siblings", "object");
  checkParameter(proof.pathIndices, "proof.pathElements", "object");
  var node = proof.leaf;
  for (var i = 0; i < proof.siblings.length; i += 1) {
    var children = proof.siblings[i].slice();
    children.splice(proof.pathIndices[i], 0, node);
    node = hash2(children);
  }
  return proof.root === node;
}
var IncrementalMerkleTree = (
  /** @class */
  function() {
    function IncrementalMerkleTree2(hash2, depth, zeroValue, arity, leaves) {
      if (arity === void 0) {
        arity = 2;
      }
      if (leaves === void 0) {
        leaves = [];
      }
      var _a;
      checkParameter(hash2, "hash", "function");
      checkParameter(depth, "depth", "number");
      checkParameter(zeroValue, "zeroValue", "number", "string", "bigint");
      checkParameter(arity, "arity", "number");
      checkParameter(leaves, "leaves", "object");
      if (depth < 1 || depth > IncrementalMerkleTree2.maxDepth) {
        throw new Error("The tree depth must be between 1 and 32");
      }
      if (leaves.length > Math.pow(arity, depth)) {
        throw new Error("The tree cannot contain more than ".concat(Math.pow(arity, depth), " leaves"));
      }
      this._hash = hash2;
      this._depth = depth;
      this._zeroes = [];
      this._nodes = [];
      this._arity = arity;
      for (var level = 0; level < depth; level += 1) {
        this._zeroes.push(zeroValue);
        this._nodes[level] = [];
        zeroValue = hash2(Array(this._arity).fill(zeroValue));
      }
      this._nodes[depth] = [];
      if (leaves.length > 0) {
        this._nodes[0] = leaves;
        for (var level = 0; level < depth; level += 1) {
          for (var index = 0; index < Math.ceil(this._nodes[level].length / arity); index += 1) {
            var position = index * arity;
            var children = [];
            for (var i = 0; i < arity; i += 1) {
              children.push((_a = this._nodes[level][position + i]) !== null && _a !== void 0 ? _a : this.zeroes[level]);
            }
            this._nodes[level + 1][index] = hash2(children);
          }
        }
      } else {
        this._nodes[depth][0] = zeroValue;
      }
      Object.freeze(this._zeroes);
      Object.freeze(this._nodes);
    }
    Object.defineProperty(IncrementalMerkleTree2.prototype, "root", {
      /**
       * Returns the root hash of the tree.
       * @returns Root hash.
       */
      get: function() {
        return this._nodes[this.depth][0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IncrementalMerkleTree2.prototype, "depth", {
      /**
       * Returns the depth of the tree.
       * @returns Tree depth.
       */
      get: function() {
        return this._depth;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IncrementalMerkleTree2.prototype, "leaves", {
      /**
       * Returns the leaves of the tree.
       * @returns List of leaves.
       */
      get: function() {
        return this._nodes[0].slice();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IncrementalMerkleTree2.prototype, "zeroes", {
      /**
       * Returns the zeroes nodes of the tree.
       * @returns List of zeroes.
       */
      get: function() {
        return this._zeroes;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IncrementalMerkleTree2.prototype, "arity", {
      /**
       * Returns the number of children for each node.
       * @returns Number of children per node.
       */
      get: function() {
        return this._arity;
      },
      enumerable: false,
      configurable: true
    });
    IncrementalMerkleTree2.prototype.indexOf = function(leaf) {
      return indexOf(leaf, this._nodes);
    };
    IncrementalMerkleTree2.prototype.insert = function(leaf) {
      this._nodes[this.depth][0] = insert(leaf, this.depth, this.arity, this._nodes, this.zeroes, this._hash);
    };
    IncrementalMerkleTree2.prototype.delete = function(index) {
      this._nodes[this.depth][0] = update(index, this.zeroes[0], this.depth, this.arity, this._nodes, this.zeroes, this._hash);
    };
    IncrementalMerkleTree2.prototype.update = function(index, newLeaf) {
      this._nodes[this.depth][0] = update(index, newLeaf, this.depth, this.arity, this._nodes, this.zeroes, this._hash);
    };
    IncrementalMerkleTree2.prototype.createProof = function(index) {
      return createProof(index, this.depth, this.arity, this._nodes, this.zeroes, this.root);
    };
    IncrementalMerkleTree2.prototype.verifyProof = function(proof) {
      return verifyProof(proof, this._hash);
    };
    IncrementalMerkleTree2.maxDepth = 32;
    return IncrementalMerkleTree2;
  }()
);

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha3 = __toESM(require_sha3());
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}

// node_modules/@semaphore-protocol/group/dist/index.mjs
var poseidon2$1 = {};
var F = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var N_ROUNDS_F = 8;
var N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
var pow5 = (v) => {
  let o = v * v;
  return v * o * o % F;
};
function mix(state, M) {
  const out = [];
  for (let x = 0; x < state.length; x++) {
    let o = 0n;
    for (let y = 0; y < state.length; y++) {
      o = o + M[x][y] * state[y];
    }
    out.push(o % F);
  }
  return out;
}
function poseidon(_inputs, opt) {
  const inputs = _inputs.map((i) => BigInt(i));
  if (inputs.length <= 0) {
    throw new Error("poseidon-lite: Not enough inputs");
  }
  if (inputs.length > N_ROUNDS_P.length) {
    throw new Error("poseidon-lite: Too many inputs");
  }
  const t = inputs.length + 1;
  const nRoundsF = N_ROUNDS_F;
  const nRoundsP = N_ROUNDS_P[t - 2];
  const {
    C,
    M
  } = opt;
  if (M.length !== t) {
    throw new Error(`poseidon-lite: Incorrect M length, expected ${t} got ${M.length}`);
  }
  let state = [0n, ...inputs];
  for (let x = 0; x < nRoundsF + nRoundsP; x++) {
    for (let y = 0; y < state.length; y++) {
      state[y] = state[y] + C[x * t + y];
      if (x < nRoundsF / 2 || x >= nRoundsF / 2 + nRoundsP)
        state[y] = pow5(state[y]);
      else if (y === 0)
        state[y] = pow5(state[y]);
    }
    state = mix(state, M);
  }
  return state[0];
}
var poseidon_1 = poseidon;
var unstringify = {};
Object.defineProperty(unstringify, "__esModule", {
  value: true
});
unstringify.default = unstringifyBigInts;
function unstringifyBigInts(o) {
  if (Array.isArray(o)) {
    return o.map(unstringifyBigInts);
  } else if (typeof o == "object") {
    const res = {};
    for (const [key, val] of Object.entries(o)) {
      res[key] = unstringifyBigInts(val);
    }
    return res;
  }
  const byteArray = Uint8Array.from(atob(o), (c2) => c2.charCodeAt(0));
  const hex = [...byteArray].map((x) => x.toString(16).padStart(2, "0")).join("");
  return BigInt(`0x${hex}`);
}
var _2 = {};
Object.defineProperty(_2, "__esModule", {
  value: true
});
_2.default = void 0;
var _default = {
  C: ["DumlkrqalRjQWYbWVvQMIRTEmTwRuymTjSHUcwTNjm4=", "APFEUjXyFIxZhlhxafwbzYh7CNTQCGjfVpb/9AlW6GQ=", "CN/zSH6KyZ4fKaBY0PqAuTDHKHMLerNs6HnziQ7Pc/U=", "Lye+aQ/a7kbDzij3UysTyFbDU0LIS9puIJZjEPrcAdA=", "KyrhrPaLe40kFr6/PU9iNLdj/gS4BD7ki4MnvryhbPI=", "AxnQYgcr737MperAb5fU1VlSwXWrawPq5ktEx9vxHPo=", "KIE9yuuuqoKKN234evSmO8i3vyetScYpjvezh78oUm0=", "JydnOyzLyQPxgb844cHUDSAzhlIAw1K8FQkord35y3g=", "I07EXKJ3J8LnSr0rKhSUzW771D40BYfWuPueMeZcxjI=", "FbUlNAMa4Y9/hiyyz3z3YKsQqBUKM3sczZn/boeX1Cg=", "Dcj61tnks19e2aPRhrec444Oio0bWLEy1wHU7s9o0fY=", "G82V/8IR+8pgD3BfrT+1Z+pOs3j2Lh/sl4BVGKR+TZw=", "EFILCrchyt/p7/gbAW/DTcdto2wleJN4F8uXjQad5Vk=", "H21IFJuOf32bJX2O1fu69CkySYB1/tCs6IqeuB9WJ/Y=", "HZZV9lIwkBTSngDvNaIIm//43ByBbw3JyjS9tUYMhwU=", "BN9aVv+VvK+wUfexzUOpm6cx/2fkcDIFj+PUGFaXzH0=", "BnLZlfj/9kAVGz0pDO2vFIaQoQqMhCSn9uwoK25L6Cg=", "CZlStBSIRFSyEgDX/6/dXwyancwG8nCOn8HYIJtcdbk=", "BSy6IlXf0Ax8SDFDuo1GlEjkNYaptM2Rg/0OhDprn6Y=", "C4ut7mkK246wvXRxK3mZr4LeVXByUa13Fgd8uTxGTdw=", "EZsVkPEzB69aHuZRAgwHx0nBXWBoOoBQuWPQqOSyvdE=", "AxULfNbV0XslKdNr4PZ7gyxKz8iE707lzhW+C/tKjQk=", "LMYYLF4UVG488ZUfFzkSNVN077g9gImKvmnLMXyepWU=", "AFAyVR5jeMRQz+EppASzdkIYyt7awU4rktLNcxEb8Pk=", "IzI34yibqjS7FH6XLry5UWRpw5n8wGn7iPnaLMKCdrU=", "Bcj09OvUpuPJgNMWdL++YyMDfyGzSuWk6AwtTCTWAoA=", "CnsdsTBC05a6BdgYoxnyUlK8817zru2R7h8JslkPxls=", "KnO3H5shDPWxQpZXLJ0y2/FW4rCG/0fcXfVCNlpATsA=", "GsmwQXq8yaGTUQfp/8kdw+wY8sTb5/Ipdqdgu1xQxGA=", "EsAzmuCDdII/q7B2cH70eSafPk1ssQQ0kBXuBG3JP8A=", "C3R1sQKhZa1/WxjbTh5wT1KQCqMlO6rGgkZoLlbpoo4=", "A3woSeGRyj7bHF5J9ui4kXyEPjeTZvLqMqs6qI1/hEg=", "BaaBH4VW8BTpJnRmHiF+m9UgbFyToH3BRf2xdqcWNG8=", "KaeV59mAKJRulHt11U6fBEB26Hp7KIO0e2de9fOL1m4=", "IEOaDISzIutFo4V6/Bj1gm6Mc4LIoVhcUHvhmZgf0i8=", "Lguo2U2ez0qU7CBQxzcf8btQ8neZqEttSipvKgmCyIc=", "FD/RFc4I+yfKOOt8zoIrRReCLNIQkEjS5tDdzKF9ccg=", "DGTL7LHHNLhXlo273PgTzfhhFlkyPby/yEMjYjvpyvE=", "AoowWEfGg/ZG/KklwWP/WudPNI1iwrZw8UJs75QD2lM=", "Lk71EP8Lb9pfqUCrTEOA8mpry2TYlCe4JNZ1W1254ww=", "AIHJW8QzhOZj15JwyVbOO4kltPbQM7B4uWOE9QV5QA4=", "LtXwyRy9l0kYfi+t5ofgXuJJGzScA5oLuoqfQCOguzg=", "MFCZkfiNo1BLvzdO1ari8DRIoix2I0yMmQ8B8zpzUgY=", "HD8g/VVAmlMiG3xNSaNWufChEZ+yBntBp1KQlEJOxq0=", "ELTn86td8AMElRRFm24Y7sRrsiE+jhMeFwiHtH3cuWw=", "KhmCl5w/9/Q93VQ9iRwqvd2A+ATAd9d1A5qjUC5Dre8=", "HHTuZPFeHbb+3b6tVtbVXbpDHrw5bJr5XK0PExW9XJE=", "B1M+yFC6f5jquTA8rOAbS55PLouCcIz6nC/kWgrhRqA=", "IVdrQ45QBEmhUeTurxexVChcaPQtQsGAihGr83ZMB1A=", "LxfAVZuP55YIrVyhk9YvELzoOEyBXwkGdD1pMINtSp4=", "LUd+OGLQdwinnoqulGFwvJd1pCATGEdK5mWwsbficw4=", "Fi9SQ5ZwZMOQ4JVXeYTyka+6ImbDj1q82Jvg9bJ0fqs=", "K0yyM+3pukgmTs0siuUNGteoWWqH8p+Kd3enAJI5MxE=", "LI+8st2Fc9wduvj0YihUd22y7s5thcTPQlTnw14DsHo=", "HW80dyXkgWry/0U/DNVrGZ4bYen2Aemt5eiNuHCUnak=", "IEsMOX9OvnHrwtiz31uRPfnmrAK2jTEyTNSa9cRWVSk=", "DEy53DxP2BdPEUmzxjw8L57LgnzX3CVTT/j7dbx5xQI=", "F0rWGhRIyJmiVBZHT0kwMB5cSUdSeeBjmmFt3EW8e1Q=", "GpYXe89NjYn3Wd9OwvPN4uqqKMF3zA+hOpgW1Jo40u8=", "Bm0EskMx1xzQ74BUvGDE/wUgLBJqIzwagkKs42C4owo=", "KkxPxuwLDPUhlXgoccbdOzgcxl9y4CrVJwN6Yqob2AQ=", "E6stE2zPN9RH6fLhSnztyV5yf4RG9tnX5Vr8ASGf1kk=", "ESFVL8omBhYZ0k2EPcgnacGwT87Cb1UZTC4+hprMapo=", "AO9lMyKxPWyIm8gXFcN9d6bNJn1ZXEqJCaVUbHyXz/E=", "DiVIPkWmZSCLJh2Lp0BR5kAMd21lJZXZhFrKNdijl9M=", "KfU23LnddoIkUmRlnhXYjjlaw9Td6S2MRkSNuXnuuok=", "KlbvnyxT/rrf2jNXXb29iFoSTieAu+oXDkVrqs4Ppb4=", "HINhx461z13s+3otF7XECfKuKZmkZ2Lo7kFiQKjLmvE=", "FRr/XziyCg/ARzCJqvAga4Po5op2RQe/09CrS+dDGcU=", "BMYYfkHtiB3BsjnIj3+dQ6n1L8jIts3R525HYVtR8QA=", "E7N72A9NJ/sQ2EMx9vttU0uBxh7RV3ZEnoAbfdycKWc=", "AaXFNic8LZ31eL+9MsF7eizjZkwqUgMskyHOscToqOQ=", "KrNWGDTKc4Na0F9desuVC0qaLGZrlybagyI5Blt8OwI=", "HU2OwpHnINsgD+bWhsDWE6yvavTpXTv2n37VFqWXtkY=", "BBKU0sxITSKPV4T+eRn9K7klNRJAoEtxFRTJyAtlrx0=", "FUrJjgFwjGEcT6cVmR8ASJj1eTnRJuOSBClx3ZDoH8Y=", "CzOdisyn1Pg+7dhAk671EFCzaEyI+LCwRSRWO8bqTaQ=", "CVXknmYQyUJUpPhM+6s0RZjw5x6v9Kfdge2VtQg5yC4=", "BnRqYVbrpUQmueIiBvFavKmm9B5vU1xvNSVAHqBlRiY=", "Dxj1oOzRQjxJbzggxUnCeDjleQ4r0KGWrJF8f/Mgd/s=", "BPbuyhdR9zCKxZ7/W+smHku1Y1g+3nvJKnOCI9b3bhM=", "K1aXM2TExPXBo+xNo83OA4gR6xFvs+RbwXaNJvwLN1g=", "Ejdp3UnVsFTc12uJgEsby44TkrOFcWpdg/62XUN/Ke8=", "IUe0JPxIyAqI7lK5EWmqzqmJ9kRkcRUJlCV7L7AcY+k=", "D9wfWFSLhXAabFUF6jMqKWR+bzStQkPC6lStiXzr5U0=", "Ejc6glH+oATfaKvPD3eG1Lzv8oxdu+DDlE9oXMCgsfI=", "IeT06l81+FutfqUv90LJ6KZCdWtq9EID3YofNcGpADU=", "FiQ5FtadLKPftHIiJNTEYrVzZkkvRekNioGTTxvDsUc=", "HvvkbdeleLT2b5rbyItDeKvCFWbhoEU8oTpBWcrASsI=", "B+pehTfPXdCIhgIOI6fzh9Ro1VJb5m+FO2csyWqIlpo=", "BajE+ZaLiqO3tHijD5pbY2UPGadefOEcqf4WwLdsALw=", "IPBXcSzCFlT7/lm9NF6NrD94GMcBuceILZ1Xtyoy6D8=", "BKEu3tqd/WiWcvjGf+4xY23NjojQHUkBm9kLM+sz22k=", "J+iNjBXzfc7kTx5UJaUd7L0TbOUJGmdn5J7JVEzNEBo=", "L+7Re4QoXtm4pcjF6VpB9m4JZhmncDIjF2xB7kM95NE=", "HtfMdu30XHxAQkFCD3Kc85TllCkRMSoNaXK4vVOv8rg=", "FXQumbm/oyMVf/jFhvVmDqxng0dhRM3K3yh0vkVGaxo=", "GqwoU4f2XoLIlfxoh930BXcQdFTG7AMXKE8DPyfQx4U=", "JYUcPIRdR5D53a29tgVzV4MuLnpJd19x7HWpZVTWfHc=", "FaWCFWXMLsLOeEV9sZft81O367osVSM3DdzMPZ8Uamc=", "JBHVekgTuZgO+n4xodtZZtz2TzYEQndQLxVIXyjHFyc=", "AC5vjWUgzUcT4zW4wLbS5kfpqY4S9M0lWIKLXvbLTJs=", "L/e8j0OAzemX2gC2FrD80a+PDpHi/h7XOYg0YJ4DFdI=", "ALmDG5SFJVle4CckRxvNGC6VIfa3u2jx6Tvk/rsNPL4=", "Ci9TdouOv2qGkTsOV8BOARykCGSKR0OofXetvwycNRI=", "ACSBVhQv0Dc6R5+R/yOelg9Zn/fpS+abfyopAwXhGY0=", "Fx1WILh7+xMoz4wCqz8MmjlxlqpqVCwjUOtRKisrzak=", "FwpPVVNvfclwCHx8ENb612DJUhct1U3ZnRBF5Ow0qAg=", "KaujP3mf5mwu8xNK6gQzbsw344wc0hG6SC7KF+Lb+uE=", "HpvBeaT911j90bsZRQiNR+cNEUoD9qDotbplA2nmSXM=", "HdJpeZtmD61Y9/SJLfsLWv6q2GmpxLRPnJ4cQ72vjwk=", "Is28i3ARetFAEYHQLhVFnnzNQm/oacfJXR3Syw8krzg=", "DvBC5FR3HFM6n1elXFA/zv0xUPUu2Up81bqTucfazv0=", "EWCeBq1sj+Lyh/MDYDfohRMY6LCKA1mgOzBP/KYugoQ=", "EWbZ5VRhbbqedT7qQnwXt/7NWMB23+QnCLCPW3g6qa8=", "LeUpiUMahZWTQTAmNUQT2xd/v0zSrAtW+FWoiDV+5GY=", "MAbrT/x6hYGabaSS86isHfUa7lsXuOiddL8Bz19x6a0=", "KvQfu2G6ioD9z2//nj9vQimT/o8KRjn5YjRMgiUUUIY=", "EZ5oTeR2FV/lprQajryF24cYqyeInoXngbIUus5IJ8M=", "GDW3huLokl4Yi+pZrjY1N7USSMI4KPBHz/eEuXs/2AA=", "KCAaNMWU36NNeUmWxkM6INFSusKnkFySbEDihasy7rY=", "CD79eifRdRCU6A/vr3iwAIZMgutXEYdySnYfiMIsxOc=", "C2+Io1dxmVJhWOYc7qJ76BHBbfd3TdhRngeVZPYf0Ts=", "Dsho5tFeUdlkT2bh1kcalFiVEcoA0p4QFDkObuQlT1s=", "KvM+P4ZncScawMmz7S4RQuzT50uTnNQNANk3q4TJhZE=", "C1ICEfkEtefQm12WHGrOdzRWjFR91oWLNkzl5HlR8Xg=", "Cy1yLQkZoarY21jxAGKpLqDFasQnDoIsyiKGIBiKHUA=", "H3kNTX+M8JTZgM6zfCRT6Ve1SpmRyji74AYdHtblYtQ=", "AXHrld+/fR6uqXzThfeAFQiFwWI1oqao2pLOsB5QQjM=", "DC0OO1/VdUkym/aIXaZrm3kLQN79LIZQdiMFOBsWiHM=", "EWL7KGicJxVOWoIotOcrN3y8r6WJ4oPDXTgDBUQHoY0=", "LxRZtl3uRBtkrThqkegxDygsWpKonhmSFiPvgklxG8A=", "Hm/zIWtojD2ZbXQ2fVzUwbxInUZ1TrcSwkP3DRtTz7s=", "AcqL5zgyuNBoFIfSfRV4AtdBpvNs3CoFdogfkyZHiHU=", "H3c1cG/+n8WG+XbVvfIj3GgChggLEM6gC5td4xX5ZQ4=", "JSK2D06jMHZAoMLc4EH7qSGsEKPV8JbvR0XKg4KF8Bk=", "I/C+4AGxAp1SVQdd3JV/gzQYytT1K2w/jOFsI1VyV1s=", "K8Gui43buB/KrC1EVV7VaF0UJjPp35BfZtlAEJMILVk=", "D5QGuCllZKNzBFB7jbo+0WI3EnOgex/JgBH81q1yIF8=", "I2Co6wzH3vpntymY3pBxThfnWxdKUu5KyxJsjNmV8Kg=", "FYcaXN3q2XaATIA8uu8lXrSBWl6W34sAbcu8J2f4iUg=", "GTpWdmmY7p4KhlLdLzsdoDYvT1T3I3lUT5V8ze77Qg8=", "KjlKQ5NPhpgvm+Vv9PqxcDsuY8itM0g05DCYBed3rg8=", "GFmVTP64aV8+i2NdyzRRkoks0RIjRDuntBZuiHbA0UI=", "BOEYF2MFDlgBNETby5nxkCsRvCXZC73KQI04GfT+0ys=", "D9slPe6Dhp1AwzXqZN6MW7EOuC2wi16LH15VUr/QXyM=", "BYy+ippQJ72qTvtiOt6tYnXwhobxwImEqdfFuum08cA=", "E4Ltzplx4YZJfq2xrrH1KyO0uDvvAjqw0VIotMzspZo=", "A0ZJkPBFxu4IGcpR/RGwvn9huOuZ8Ut34eZjRgHZ6LU=", "I/e/yHINwpb/8ztB+Y/4PG/KtGBdsutaqlvBN663Clg=", "ClmhWOPuwhF+bpTn8OnezxjD/9XhUxqSGWNhWLuvYvI=", "BuxUyAOBwFK1i/I7MS/9POLE66BlQgr49MI+0Adf0Hs=", "EYhy3IMuDrVHa1ZkjoZ+yLCTQPenvLG0li8P+e0fnQE=", "E9afoSfYNBZa1cfLp61Z7VLgsPDkLX/qleGQa1IJIbE=", "FpoXf2PqaBJwscaHenPSG94UOUL7cdxV/YpJ8Z8Qx3s=", "BO9RWRxurZfvQvKHrc5A2Tq+sDK5IvZv+36aWnRQVE0=", "JW4XWh3AeTkOzXynA/suOxnsYYBdTwPO1fRe5t0Paew=", "MBAtKGNqvV/l8q9BL/YAT3XMNg0yBd0toAKBPT4s7rI=", "EJmOQt/NO78cBxS8c+sb9ARDo/qZvvSjH9Mb4YL8x5I=", "GT7djp/PPXYl+n0ktZih2J8zYur01YLv7K12+HnjaGA=", "GBaK/TTy2RXQNozoC3szR9HHpWHOYRQl8mZNeqUfC10=", "KTg8AevTtqsMAXZW6+ZYtqMo7He8M2JuKeLpWzPqYRE=", "EGRtLyYD3jmh9K5ed3GmSnAttuhvt2q2AL9XP5AQxxE=", "C+teB9GycUX1dfE5WlW/Ey+QwltA2ns4ZNAkLcsRF/s=", "FtaFJSB4wTPcDT7K1itciDD5W7LlS1mr3/vwGNlvozY=", "Cmq9HYM5OPM8dBVOBAS0tApVW7vsId36/Wct1iBH8Bo=", "GmefXTbre1yOoSpMLe3I/rEt/+7EUDFycKbxmzTPGGA=", "CYD7IzvUVsI5dNUODr/eRyakI+raTo9v+8dZLj8bk9Y=", "FhtCIy5huEy/GBCvk6OPwM7OPVYoySggA+ustcMSxys=", "CtoQqQx/BSCVD31Hpg1eakk/CXh/FWTl0JID20feGgs=", "GnMNNyMQuoIyA0WimsQjjtPweoorThIbtQ3bmvQH9FE=", "LIEg8mjvBU+BcGTDad2n6pCDd/6rpcTf+9oQ71joxVY=", "HHyIJPdYdT+lfAB4nGhCF7kw6VMTvLc+bnuGSaSWj3A=", "LNntMfX4aRyOOeQHenT6oPQArYtJHrP3tHsn+j/Rz3c=", "I/9PnUaBNFfPYNkvV2GDmaXgIqwyHKVQhUriORiiLuo=", "CZRaXRR6T2bO7OZAXd3Z0K9aLFEDUpQH3/HqWPGAQm0=", "GI2cUoAl1MK2dmDGt3G5D3x9puqinT8mim3SI+xvxjA=", "MFDjeZZZa3+B9oMRQx2HNNun2SbTYzWV4MDY3fTw9H8=", "Fa8RaTloMKkWAMqBAsNcQmzq5UYeP5XYnYKVGNMK/Xg=", "HabQmIVDLqmgbZ83+HPZhdrpM+NRRmspBChNozINisw=", "J5bqkNJpryn1+KzzOSESTk5PrT2+ZYlF5UbuQR3aqcs=", "IC190doPa0sDJcizMHdC8B4VYS7I6TBKfLAxngHTLWA=", "CW1nkNBbt1kVapUromPWcqLX+ceI9Mgxop2s5MD4vl8=", "BU76H2Ww/OKDgIllJ12He0ONojzlsT4ZY3mMsUR9JaQ=", "GxYvg9kX6T7bMwjCmALeudiqaQETsuFIZMz24Y5BZfE=", "IeUkHhJWTdb9nxzdKg3jnu3+/BRmzFaOxc63RaBQbtw=", "HPtWYujPWskiaoDuF7Nqvstzq1+H4WGSe0NJ4Q5L3wg=", "DyEXfjAqdxu65tjR7LNztiyZrzRiIKwBKcU/Zm6yQQA=", "FnFSI3RgaZKv+w3X9xsSvsQjau3mKQVGvO9+H1FcIyA=", "D6PsW5SIJZwutM8kUBv62b4uyeQsXMjM1BnSppLK2HA=", "GTwOBOC9KYNXyyZsFQYIDtNu3OhcZIzAhejFexq1S7o=", "ECrfjvdHNaJ+kSgwbcvDyZ9vcpHNQGV4zhTqKtq6aPg=", "D+CveFjkmFnipU1vGtlFsTFqokv73SOuQKbQy3DD6rE=", "IW9nF7vH3tsIU2oiIIQ/Ti2l8dqp69796KXqc0R5jSI=", "HaVcyQDw0h9KPmlDkZGKGzwjsqx3PGs++I4uQigyUWE="],
  M: [["EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Fu1B4Tu5wMZq4RlCT928vJMU3J/b3upV1sZFQ9xJA+A=", "K5C7oA/KBYn2F+fcv+guDfcGq2QM6yR7eRqTt042c20="], ["KWnyfu0xpIC5w2x2Q3nbyizI/dFBXD3e1ilAvN4L13E=", "LiQZ+ewC7DlMmHHIMpY9wbiddDyMe5ZAKbIxFoex/iM=", "EBBx8AMjebaXMVh2aQ8FPRSNThCfX7BlyKrMVaD4m/o="], ["FDAh7GhqPzMNX55lRjgGXObNeeKMWzdTMmJE7mWhsac=", "F2zAKWla0CWCpw7/CKb9mdBX4S5Y59e2sWzfq8juKRE=", "GaP8ClZwK/QXun/uOAJZP6ZERwMHBD93cyec1x0l1eA="]]
};
_2.default = _default;
Object.defineProperty(poseidon2$1, "__esModule", {
  value: true
});
var poseidon2_2 = poseidon2$1.poseidon2 = poseidon2;
var _poseidon = _interopRequireDefault(poseidon_1);
var _unstringify = _interopRequireDefault(unstringify);
var _ = _interopRequireDefault(_2);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var c = (0, _unstringify.default)(_.default);
function poseidon2(inputs) {
  return (0, _poseidon.default)(inputs, c);
}
function hash(message) {
  message = BigNumber.from(message).toTwos(256).toHexString();
  message = zeroPad(message, 32);
  return BigInt(keccak256(message)) >> BigInt(8);
}
var Group = (
  /** @class */
  function() {
    function Group2(id, treeDepth, members) {
      if (treeDepth === void 0) {
        treeDepth = 20;
      }
      if (members === void 0) {
        members = [];
      }
      if (treeDepth < 16 || treeDepth > 32) {
        throw new Error("The tree depth must be between 16 and 32");
      }
      this._id = id;
      this.merkleTree = new IncrementalMerkleTree(poseidon2_2, treeDepth, hash(id), 2, members.map(BigInt));
    }
    Object.defineProperty(Group2.prototype, "id", {
      /**
       * Returns the id of the group.
       * @returns Group id.
       */
      get: function() {
        return this._id;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Group2.prototype, "root", {
      /**
       * Returns the root hash of the tree.
       * @returns Root hash.
       */
      get: function() {
        return this.merkleTree.root;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Group2.prototype, "depth", {
      /**
       * Returns the depth of the tree.
       * @returns Tree depth.
       */
      get: function() {
        return this.merkleTree.depth;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Group2.prototype, "zeroValue", {
      /**
       * Returns the zero value of the tree.
       * @returns Tree zero value.
       */
      get: function() {
        return this.merkleTree.zeroes[0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Group2.prototype, "members", {
      /**
       * Returns the members (i.e. identity commitments) of the group.
       * @returns List of members.
       */
      get: function() {
        return this.merkleTree.leaves;
      },
      enumerable: false,
      configurable: true
    });
    Group2.prototype.indexOf = function(member) {
      return this.merkleTree.indexOf(member);
    };
    Group2.prototype.addMember = function(member) {
      this.merkleTree.insert(BigInt(member));
    };
    Group2.prototype.addMembers = function(members) {
      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {
        var member = members_1[_i];
        this.addMember(member);
      }
    };
    Group2.prototype.updateMember = function(index, member) {
      this.merkleTree.update(index, member);
    };
    Group2.prototype.removeMember = function(index) {
      this.merkleTree.delete(index);
    };
    Group2.prototype.generateMerkleProof = function(index) {
      var merkleProof = this.merkleTree.createProof(index);
      merkleProof.siblings = merkleProof.siblings.map(function(s) {
        return s[0];
      });
      return merkleProof;
    };
    return Group2;
  }()
);
export {
  Group
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

@zk-kit/incremental-merkle-tree/dist/index.mjs:
  (**
   * @module @zk-kit/incremental-merkle-tree
   * @version 1.1.0
   * @file Incremental Merkle tree implementation in TypeScript.
   * @copyright Cedoor 2023
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/incremental-merkle-tree}
  *)

@semaphore-protocol/group/dist/index.mjs:
  (**
   * @module @semaphore-protocol/group
   * @version 3.15.2
   * @file A library to create and manage Semaphore groups.
   * @copyright Ethereum Foundation 2022
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/group}
  *)
*/
//# sourceMappingURL=@semaphore-protocol_group.js.map
