import { PCDCollection } from "@pcd/pcd-collection";
import { SerializedPCD } from "@pcd/pcd-types";
import { Identity } from "@semaphore-protocol/identity";
import { CredentialRequest } from "./SubscriptionManager";
export interface CredentialManagerAPI {
    canGenerateCredential(req: CredentialRequest): boolean;
    requestCredential(req: CredentialRequest): Promise<SerializedPCD>;
    prepareCredentials(reqs: CredentialRequest[]): Promise<void>;
}
export type CredentialCache = Map<string, CacheEntry>;
interface CacheEntry {
    timestamp: number;
    value: SerializedPCD;
    request: CredentialRequest;
}
/**
 * These constants are convenient values for credential requests.
 * PODBOX_CREDENTIAL_REQUEST requires an EmailPCD, since this is commonly
 * required for Podbox requests.
 * ZUPASS_CREDENTIAL_REQUEST does not, as Zupass can identify users by their
 * Semaphore ID alone.
 */
export declare const PODBOX_CREDENTIAL_REQUEST: CredentialRequest;
export declare const ZUPASS_CREDENTIAL_REQUEST: CredentialRequest;
export declare function createCredentialCache(): CredentialCache;
export declare function createStorageBackedCredentialCache(): CredentialCache;
/**
 * Handles generation of credentials for feeds.
 */
export declare class CredentialManager implements CredentialManagerAPI {
    private readonly identity;
    private readonly pcds;
    private readonly cache;
    constructor(identity: Identity, pcds: PCDCollection, cache: CredentialCache);
    canGenerateCredential(req: CredentialRequest): boolean;
    /**
     * Before doing a parallel fetching of subscriptions, it can be helpful to
     * prepare the credentials to avoid race conditions.
     */
    prepareCredentials(reqs: CredentialRequest[]): Promise<void>;
    private getCachedCredential;
    private setCachedCredential;
    private purgeExpiredCredentials;
    /**
     * Returns a requested credential, either from the cache or by generating it.
     */
    requestCredential(req: CredentialRequest): Promise<SerializedPCD>;
    /**
     * Generates the requested credential, if possible.
     * Takes a {@link CredentialRequest} and produces a serialized PCD which
     * consists of a signature PCD (e.g. a semaphore signature PCD) which wraps
     * a {@link FeedCredentialPayload}. This payload contains a timestamp, and
     * may contain a PCD if a) the feed requests one and b) CredentialManager
     * can find a matching PCD.
     */
    private generateCredential;
    private semaphoreSignPayload;
}
export {};
//# sourceMappingURL=CredentialManager.d.ts.map