"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZKEdDSAEventTicketPCDPackage = exports.isZKEdDSAEventTicketPCD = exports.getDisplayOptions = exports.deserialize = exports.serialize = exports.verify = exports.prove = exports.getProveDisplayOptions = exports.snarkInputForValidEventIds = exports.init = exports.STATIC_TICKET_PCD_NULLIFIER = void 0;
const eddsa_pcd_1 = require("@pcd/eddsa-pcd");
const eddsa_ticket_pcd_1 = require("@pcd/eddsa-ticket-pcd");
const pcd_types_1 = require("@pcd/pcd-types");
const semaphore_identity_pcd_1 = require("@pcd/semaphore-identity-pcd");
const semaphore_signature_pcd_1 = require("@pcd/semaphore-signature-pcd");
const util_1 = require("@pcd/util");
const circomlibjs_1 = require("circomlibjs");
const json_bigint_1 = __importDefault(require("json-bigint"));
const snarkjs_1 = require("snarkjs");
const uuid_1 = require("uuid");
const circuit_json_1 = __importDefault(require("../artifacts/circuit.json"));
const ZKEdDSAEventTicketPCD_1 = require("./ZKEdDSAEventTicketPCD");
exports.STATIC_TICKET_PCD_NULLIFIER = (0, util_1.generateSnarkMessageHash)("dummy-nullifier-for-eddsa-event-ticket-pcds");
let depsInitializedPromise;
let eddsa;
let savedInitArgs = undefined;
/**
 * Initialize ZKEdDSAEventTicketPCDPackage.
 */
async function init(args) {
    savedInitArgs = args;
}
exports.init = init;
async function ensureDepsInitialized() {
    if (!depsInitializedPromise) {
        depsInitializedPromise = (async () => {
            // TODO: This object is expensive to build, and duplicates some work,
            // including buiding curves which aren't cached and thus have to be
            // re-built by groth16.  We need this object only for eddsa.F.toObject
            // and eddsa.unpackSignature.  To improve performance, we could tweak
            // circomlibjs and/or zk-kit/groth16 either to expose those functions in a
            // more limited way, or to cache all the expensive parts which will be
            // needed later.
            eddsa = await (0, circomlibjs_1.buildEddsa)();
        })();
    }
    await depsInitializedPromise;
}
async function ensureInitialized() {
    if (!savedInitArgs) {
        throw new Error("Cannot initialize ZKEdDSAEventTicketPCDPackage: init has not been called yet");
    }
    await ensureDepsInitialized();
    return savedInitArgs;
}
async function checkProveInputs(args) {
    const serializedTicketPCD = args.ticket.value?.pcd;
    if (!serializedTicketPCD) {
        throw new Error("Cannot make proof: missing ticket PCD");
    }
    const serializedIdentityPCD = args.identity.value?.pcd;
    if (!serializedIdentityPCD) {
        throw new Error("Cannot make proof: missing identity PCD");
    }
    const fieldsToReveal = args.fieldsToReveal.value;
    if (!fieldsToReveal) {
        throw new Error("Cannot make proof: missing fields request object");
    }
    if (!args.watermark.value) {
        throw new Error("Cannot make proof: missing watermark");
    }
    if (args.externalNullifier.value !== undefined &&
        BigInt(args.externalNullifier.value) === semaphore_signature_pcd_1.STATIC_SIGNATURE_PCD_NULLIFIER) {
        throw new Error("Cannot make proof: same externalNullifier as SemaphoreSignaturePCD, which would break anonymity");
    }
    const deserializedTicket = await eddsa_ticket_pcd_1.EdDSATicketPCDPackage.deserialize(serializedTicketPCD);
    const identityPCD = await semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.deserialize(serializedIdentityPCD);
    return {
        ticketPCD: deserializedTicket,
        identityPCD: identityPCD,
        fieldsToReveal: fieldsToReveal,
        watermark: BigInt(args.watermark.value)
    };
}
/**
 * Convert a list of valid event IDs from input format (variable-length list
 * of UUID strings) to snark signal format (fixed-length list of bigint
 * strings).  The result always has length VALID_EVENT_IDS_MAX_LEN with
 * unused fields are filled in with a value of BABY_JUB_NEGATIVE_ONE.
 */
function snarkInputForValidEventIds(validEventIds) {
    if (validEventIds === undefined) {
        validEventIds = [];
    }
    if (validEventIds.length > ZKEdDSAEventTicketPCD_1.VALID_EVENT_IDS_MAX_LEN) {
        throw new Error("validEventIds for a ZKEdDSAEventTicketPCD can have up to 100 entries.  " +
            validEventIds.length +
            " given.");
    }
    const snarkIds = new Array(ZKEdDSAEventTicketPCD_1.VALID_EVENT_IDS_MAX_LEN);
    let i = 0;
    for (const validId of validEventIds) {
        snarkIds[i] = (0, util_1.uuidToBigInt)(validId).toString();
        ++i;
    }
    for (; i < ZKEdDSAEventTicketPCD_1.VALID_EVENT_IDS_MAX_LEN; ++i) {
        snarkIds[i] = util_1.BABY_JUB_NEGATIVE_ONE.toString();
    }
    return snarkIds;
}
exports.snarkInputForValidEventIds = snarkInputForValidEventIds;
function snarkInputForProof(ticketPCD, identityPCD, fieldsToReveal, validEventIdsInput, externalNullifer, watermark) {
    const ticketAsBigIntArray = (0, eddsa_ticket_pcd_1.ticketDataToBigInts)(ticketPCD.claim.ticket);
    const pubKey = ticketPCD.proof.eddsaPCD.claim.publicKey;
    // Note: unpackSignature leaves the R8 point's coordinates in Montgomery
    // form, which is then reversed by toObject below.
    // This is a reference to Montgomery form of numbers for modular
    // multiplication, NOT Montgomery form of eliptic curves.  See https://en.wikipedia.org/wiki/Montgomery_modular_multiplication#Montgomery_form
    const rawSig = eddsa.unpackSignature((0, util_1.fromHexString)(ticketPCD.proof.eddsaPCD.proof.signature));
    const checkValidEventIds = validEventIdsInput !== undefined;
    return {
        // Ticket data fields
        ticketId: ticketAsBigIntArray[0].toString(),
        revealTicketId: fieldsToReveal.revealTicketId ? "1" : "0",
        ticketEventId: ticketAsBigIntArray[1].toString(),
        revealTicketEventId: fieldsToReveal.revealEventId ? "1" : "0",
        ticketProductId: ticketAsBigIntArray[2].toString(),
        revealTicketProductId: fieldsToReveal.revealProductId ? "1" : "0",
        ticketTimestampConsumed: ticketAsBigIntArray[3].toString(),
        revealTicketTimestampConsumed: fieldsToReveal.revealTimestampConsumed
            ? "1"
            : "0",
        ticketTimestampSigned: ticketAsBigIntArray[4].toString(),
        revealTicketTimestampSigned: fieldsToReveal.revealTimestampSigned
            ? "1"
            : "0",
        ticketAttendeeSemaphoreId: ticketAsBigIntArray[5].toString(),
        revealTicketAttendeeSemaphoreId: fieldsToReveal.revealAttendeeSemaphoreId
            ? "1"
            : "0",
        ticketIsConsumed: ticketAsBigIntArray[6].toString(),
        revealTicketIsConsumed: fieldsToReveal.revealIsConsumed ? "1" : "0",
        ticketIsRevoked: ticketAsBigIntArray[7].toString(),
        revealTicketIsRevoked: fieldsToReveal.revealIsRevoked ? "1" : "0",
        ticketCategory: ticketAsBigIntArray[8].toString(),
        revealTicketCategory: fieldsToReveal.revealTicketCategory ? "1" : "0",
        // This field was previously reserved, but is now used for attendee email.
        // See later comment to explain the concept of reserved fields.
        reservedSignedField1: ticketAsBigIntArray[9].toString(),
        revealReservedSignedField1: fieldsToReveal.revealAttendeeEmail ? "1" : "0",
        // This field was previously reserved, but is now used for attendee name:
        reservedSignedField2: ticketAsBigIntArray[10].toString(),
        revealReservedSignedField2: fieldsToReveal.revealAttendeeName ? "1" : "0",
        // This field currently does not have any preset semantic meaning, although the intention
        // is for it to convert into a meaningful field in the future. We are reserving it now
        // so that we can keep the Circom configuration (.zkey and .wasm) as we add new fields,
        // and we would only need to change the TypeScript. For now, we will treat the inputs as
        // 0 in terms of signatures.
        reservedSignedField3: "0",
        revealReservedSignedField3: "0",
        // Ticket signature fields
        ticketSignerPubkeyAx: (0, util_1.hexToBigInt)(pubKey[0]).toString(),
        ticketSignerPubkeyAy: (0, util_1.hexToBigInt)(pubKey[1]).toString(),
        ticketSignatureR8x: eddsa.F.toObject(rawSig.R8[0]).toString(),
        ticketSignatureR8y: eddsa.F.toObject(rawSig.R8[1]).toString(),
        ticketSignatureS: rawSig.S.toString(),
        // Attendee identity secret
        semaphoreIdentityNullifier: identityPCD.claim.identity
            .getNullifier()
            .toString(),
        semaphoreIdentityTrapdoor: identityPCD.claim.identity
            .getTrapdoor()
            .toString(),
        // Valid event ID list
        validEventIds: snarkInputForValidEventIds(validEventIdsInput),
        checkValidEventIds: checkValidEventIds ? "1" : "0",
        // Security features
        externalNullifier: externalNullifer || exports.STATIC_TICKET_PCD_NULLIFIER.toString(),
        revealNullifierHash: externalNullifer ? "1" : "0",
        watermark: watermark.toString()
    };
}
function claimFromProofResult(ticketPCD, publicSignals, validEventIds, externalNullifer, watermark) {
    const partialTicket = {};
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[0])) {
        partialTicket.ticketId = (0, util_1.decStringToBigIntToUuid)(publicSignals[0]);
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[1])) {
        partialTicket.eventId = (0, util_1.decStringToBigIntToUuid)(publicSignals[1]);
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[2])) {
        partialTicket.productId = (0, util_1.decStringToBigIntToUuid)(publicSignals[2]);
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[3])) {
        partialTicket.timestampConsumed = parseInt(publicSignals[3]);
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[4])) {
        partialTicket.timestampSigned = parseInt(publicSignals[4]);
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[5])) {
        partialTicket.attendeeSemaphoreId = publicSignals[5];
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[6])) {
        partialTicket.isConsumed = publicSignals[6] !== "0";
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[7])) {
        partialTicket.isRevoked = publicSignals[7] !== "0";
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[8])) {
        partialTicket.ticketCategory = parseInt(publicSignals[8]);
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[9])) {
        partialTicket.attendeeEmail = ticketPCD.claim.ticket.attendeeEmail;
    }
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[10])) {
        partialTicket.attendeeName = ticketPCD.claim.ticket.attendeeName;
    }
    // This field is currently not typed or being used, but is being kept as
    // a reserved field that is hardcoded to zero and included in the preimage
    // of the hashed signature. As such, the flags for revealing this reserved
    // signed field should always be -1 until it is being typed and used.
    if (!(0, util_1.babyJubIsNegativeOne)(publicSignals[11])) {
        throw new Error("ZkEdDSAEventTicketPCD: reservedSignedField3 is not in use");
    }
    const claim = {
        partialTicket,
        watermark: watermark.toString(),
        signer: ticketPCD.proof.eddsaPCD.claim.publicKey
    };
    if (validEventIds !== undefined) {
        claim.validEventIds = validEventIds;
    }
    if (externalNullifer !== undefined) {
        claim.nullifierHash = publicSignals[12];
        claim.externalNullifier = externalNullifer;
    }
    return claim;
}
function getProveDisplayOptions() {
    return {
        defaultArgs: {
            ticket: {
                argumentType: pcd_types_1.ArgumentTypeName.PCD,
                description: "Generate a proof for the selected ticket",
                validate(value, params) {
                    if (value.type !== eddsa_ticket_pcd_1.EdDSATicketPCDTypeName || !value.claim) {
                        return false;
                    }
                    if (params?.eventIds?.length && params?.productIds?.length) {
                        if (params.eventIds.length !== params.productIds.length) {
                            // soft-error: dev passed invalid eventIds and productIds
                            console.error("eventIds and productIds must have the same length");
                            return false;
                        }
                        if (!params.eventIds.find((eventId, i) => eventId === value.claim.ticket.eventId &&
                            params.productIds?.[i] === value.claim.ticket.productId)) {
                            return false;
                        }
                    }
                    if (params?.eventIds?.length) {
                        if (!params.eventIds.includes(value.claim.ticket.eventId)) {
                            return false;
                        }
                    }
                    if (params?.productIds?.length) {
                        if (!params.productIds.includes(value.claim.ticket.productId)) {
                            return false;
                        }
                    }
                    if (params?.publicKeys?.length) {
                        if (!params.publicKeys.find((publicKey) => (0, eddsa_pcd_1.isEqualEdDSAPublicKey)(publicKey, value.proof.eddsaPCD.claim.publicKey))) {
                            return false;
                        }
                    }
                    return true;
                },
                validatorParams: {
                    eventIds: [],
                    productIds: [],
                    notFoundMessage: "You do not have any eligible tickets."
                }
            },
            fieldsToReveal: {
                argumentType: pcd_types_1.ArgumentTypeName.ToggleList,
                displayName: "",
                description: "The following information will be revealed"
            },
            identity: {
                argumentType: pcd_types_1.ArgumentTypeName.PCD,
                defaultVisible: false,
                description: "Your Zupass comes with a primary Semaphore Identity which represents an user in the Semaphore protocol."
            },
            validEventIds: {
                argumentType: pcd_types_1.ArgumentTypeName.StringArray,
                defaultVisible: false,
                description: "The list of valid event IDs that the ticket can be used for. If this is not provided, the proof will not check the validity of the event ID. When this is provided and event id is not directly revealed, the proof can only be used to prove that the ticket is valid for one of the events in the list."
            },
            watermark: {
                argumentType: pcd_types_1.ArgumentTypeName.BigInt,
                defaultVisible: false
            },
            externalNullifier: {
                argumentType: pcd_types_1.ArgumentTypeName.BigInt,
                defaultVisible: false
            }
        }
    };
}
exports.getProveDisplayOptions = getProveDisplayOptions;
/**
 * Creates a new ZKEdDSAEventTicketPCD.
 */
async function prove(args) {
    const initArgs = await ensureInitialized();
    const { ticketPCD, identityPCD, fieldsToReveal, watermark } = await checkProveInputs(args);
    const snarkInput = snarkInputForProof(ticketPCD, identityPCD, fieldsToReveal, args.validEventIds.value, args.externalNullifier.value, watermark);
    const { proof, publicSignals } = await snarkjs_1.groth16.fullProve(snarkInput, initArgs.wasmFilePath, initArgs.zkeyFilePath);
    const claim = claimFromProofResult(ticketPCD, publicSignals, args.validEventIds.value, args.externalNullifier.value, watermark);
    return new ZKEdDSAEventTicketPCD_1.ZKEdDSAEventTicketPCD((0, uuid_1.v4)(), claim, proof);
}
exports.prove = prove;
function publicSignalsFromClaim(claim) {
    const t = claim.partialTicket;
    const ret = [];
    const negOne = util_1.BABY_JUB_NEGATIVE_ONE.toString();
    // Outputs appear in public signals first
    ret.push(t.ticketId === undefined ? negOne : (0, util_1.uuidToBigInt)(t.ticketId).toString());
    ret.push(t.eventId === undefined ? negOne : (0, util_1.uuidToBigInt)(t.eventId).toString());
    ret.push(t.productId === undefined ? negOne : (0, util_1.uuidToBigInt)(t.productId).toString());
    ret.push(t.timestampConsumed === undefined ? negOne : t.timestampConsumed.toString());
    ret.push(t.timestampSigned === undefined ? negOne : t.timestampSigned.toString());
    ret.push(t.attendeeSemaphoreId || negOne);
    ret.push(t.isConsumed === undefined
        ? negOne
        : (0, util_1.booleanToBigInt)(t.isConsumed).toString());
    ret.push(t.isRevoked === undefined ? negOne : (0, util_1.booleanToBigInt)(t.isRevoked).toString());
    ret.push(t.ticketCategory === undefined
        ? negOne
        : (0, util_1.numberToBigInt)(t.ticketCategory).toString());
    ret.push(t.attendeeEmail === undefined
        ? negOne
        : (0, util_1.generateSnarkMessageHash)(t.attendeeEmail).toString());
    ret.push(t.attendeeName === undefined
        ? negOne
        : (0, util_1.generateSnarkMessageHash)(t.attendeeName).toString());
    // Placeholder for reserved field
    ret.push(negOne);
    ret.push(claim.nullifierHash || negOne);
    // Public inputs appear in public signals in declaration order
    ret.push((0, util_1.hexToBigInt)(claim.signer[0]).toString());
    ret.push((0, util_1.hexToBigInt)(claim.signer[1]).toString());
    for (const eventId of snarkInputForValidEventIds(claim.validEventIds)) {
        ret.push(eventId);
    }
    ret.push(claim.validEventIds !== undefined ? "1" : "0"); // checkValidEventIds
    ret.push(claim.externalNullifier?.toString() ||
        exports.STATIC_TICKET_PCD_NULLIFIER.toString());
    ret.push(claim.watermark);
    return ret;
}
/**
 * Verify the claims and proof of a ZKEdDSAEventTicketPCD.
 */
async function verify(pcd) {
    // verify() requires dependencies but not artifacts (verification key
    // is available in code as vkey imported above), so doesn't require
    // full package initialization.
    const publicSignals = publicSignalsFromClaim(pcd.claim);
    return snarkjs_1.groth16.verify(circuit_json_1.default, publicSignals, pcd.proof);
}
exports.verify = verify;
/**
 * Serialize a ZKEdDSAEventTicketPCD.
 */
async function serialize(pcd) {
    return {
        type: ZKEdDSAEventTicketPCD_1.ZKEdDSAEventTicketPCDTypeName,
        pcd: (0, json_bigint_1.default)({ useNativeBigInt: true }).stringify(pcd)
    };
}
exports.serialize = serialize;
/**
 * Deserialize a ZKEdDSAEventTicketPCD.
 */
async function deserialize(serialized) {
    const { id, claim, proof } = (0, json_bigint_1.default)({ useNativeBigInt: true }).parse(serialized);
    (0, util_1.requireDefinedParameter)(id, "id");
    (0, util_1.requireDefinedParameter)(claim, "claim");
    (0, util_1.requireDefinedParameter)(proof, "proof");
    return new ZKEdDSAEventTicketPCD_1.ZKEdDSAEventTicketPCD(id, claim, proof);
}
exports.deserialize = deserialize;
/**
 * Get display options for a ZKEdDSAEventTicketPCD.
 */
function getDisplayOptions(pcd) {
    return {
        header: "ZK EdDSA Event Ticket PCD",
        displayName: "zk-eddsa-event-ticket-" + pcd.id.substring(0, 4)
    };
}
exports.getDisplayOptions = getDisplayOptions;
function isZKEdDSAEventTicketPCD(pcd) {
    return pcd.type === ZKEdDSAEventTicketPCD_1.ZKEdDSAEventTicketPCDTypeName;
}
exports.isZKEdDSAEventTicketPCD = isZKEdDSAEventTicketPCD;
/**
 * A PCD representing a proof of ownership of an EdDSA-signed ticket. The prover
 * is able to prove ownership of a ticket corresponding to their semaphore
 * identity, and optionally prove the ticket corresponds to one of a list
 * of valid events. The prover can keep their identity private, and selectively
 * reveal some or none of the individual ticket fields. To harden against
 * various abuses, the proof can be watermarked, and can include a nullifier.
 */
exports.ZKEdDSAEventTicketPCDPackage = {
    name: ZKEdDSAEventTicketPCD_1.ZKEdDSAEventTicketPCDTypeName,
    getDisplayOptions,
    init,
    getProveDisplayOptions,
    prove,
    verify,
    serialize,
    deserialize
};
