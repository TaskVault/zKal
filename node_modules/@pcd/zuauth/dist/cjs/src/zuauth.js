"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructZkTicketProofUrl = exports.zuAuthRedirect = exports.zuAuthPopup = exports.zupassPopupSetup = void 0;
const EdDSATicketPCD_1 = require("@pcd/eddsa-ticket-pcd/EdDSATicketPCD");
const PassportInterface_1 = require("@pcd/passport-interface/PassportInterface");
const core_1 = require("@pcd/passport-interface/PassportPopup/core");
Object.defineProperty(exports, "zupassPopupSetup", { enumerable: true, get: function () { return core_1.zupassPopupSetup; } });
const pcd_types_1 = require("@pcd/pcd-types");
const SemaphoreIdentityPCD_1 = require("@pcd/semaphore-identity-pcd/SemaphoreIdentityPCD");
const ZKEdDSAEventTicketPCD_1 = require("@pcd/zk-eddsa-event-ticket-pcd/ZKEdDSAEventTicketPCD");
/**
 * Opens a popup window to the Zupass prove screen.
 */
async function zuAuthPopup(args) {
    const proofUrl = constructZkTicketProofUrl(args);
    return (0, core_1.zupassPopupExecute)(proofUrl);
}
exports.zuAuthPopup = zuAuthPopup;
/**
 * Navigates to the Zupass prove screen.
 */
function zuAuthRedirect(args) {
    const proofUrl = constructZkTicketProofUrl(args);
    window.location.href = proofUrl;
}
exports.zuAuthRedirect = zuAuthRedirect;
/**
 * Constructs a URL to the Zupass prove screen for a ZKEdDSAEventTicketPCD
 * zero-knowlege proof.
 */
function constructZkTicketProofUrl(zuAuthArgs) {
    const { zupassUrl = "https://zupass.org", returnUrl, fieldsToReveal, watermark, config, externalNullifier, proofTitle, proofDescription } = zuAuthArgs;
    const eventIds = [], productIds = [], publicKeys = [];
    /**
     * {@link constructZupassPcdGetRequestUrl} takes a set of parameters which it
     * uses to build a prove screen. Some of these are passed through to the
     * `getProveDisplayOptions` function of the relevant {@link PCDPackage},
     * which in this case is {@link ZKEdDSAEventTicketPCDPackage}.
     *
     * This package supports custom options, where the parameters can contain a
     * list of event IDs and a list of product IDs. However, it is designed to
     * support two specific scenarios:
     * 1) the lists of event IDs and product IDs are of exactly equal length
     * 2) the list of product IDs is empty
     *
     * So, the user can pass in a configuration to ZuAuth in which each item has
     * both an event ID and a product ID, or in which each item has an event ID
     * and no product ID, but can't mix the two.
     */
    for (const em of config) {
        if (em.productId) {
            if (eventIds.length > productIds.length) {
                throw new Error("It is not possible to mix events with product IDs and events without product IDs");
            }
            productIds.push(em.productId);
        }
        if (!em.productId && productIds.length > 0) {
            throw new Error("It is not possible to mix events with product IDs and events without product IDs");
        }
        eventIds.push(em.eventId);
        publicKeys.push(em.publicKey);
    }
    const args = {
        ticket: {
            argumentType: pcd_types_1.ArgumentTypeName.PCD,
            pcdType: EdDSATicketPCD_1.EdDSATicketPCDTypeName,
            value: undefined,
            userProvided: true,
            validatorParams: {
                eventIds,
                productIds,
                publicKeys,
                notFoundMessage: "No eligible PCDs found"
            }
        },
        identity: {
            argumentType: pcd_types_1.ArgumentTypeName.PCD,
            pcdType: SemaphoreIdentityPCD_1.SemaphoreIdentityPCDTypeName,
            value: undefined,
            userProvided: true
        },
        validEventIds: {
            argumentType: pcd_types_1.ArgumentTypeName.StringArray,
            value: eventIds.length !== 0 && eventIds.length <= 20 ? eventIds : undefined,
            userProvided: false
        },
        fieldsToReveal: {
            argumentType: pcd_types_1.ArgumentTypeName.ToggleList,
            value: fieldsToReveal,
            userProvided: false
        },
        watermark: {
            argumentType: pcd_types_1.ArgumentTypeName.BigInt,
            value: BigInt(watermark).toString(),
            userProvided: false
        },
        externalNullifier: {
            argumentType: pcd_types_1.ArgumentTypeName.BigInt,
            value: externalNullifier
                ? externalNullifier.toString()
                : BigInt(watermark).toString(),
            userProvided: false
        }
    };
    return (0, PassportInterface_1.constructZupassPcdGetRequestUrl)(zupassUrl, returnUrl ?? "", ZKEdDSAEventTicketPCD_1.ZKEdDSAEventTicketPCDTypeName, args, {
        genericProveScreen: true,
        title: proofTitle,
        description: proofDescription
    }, true);
}
exports.constructZkTicketProofUrl = constructZkTicketProofUrl;
